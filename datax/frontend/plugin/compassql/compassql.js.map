{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/src/bins/bins.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/time.js",
    "node_modules/datalib/src/util.js",
    "src/config.js",
    "src/constraint/base.js",
    "src/constraint/constraint.js",
    "src/constraint/encoding.js",
    "src/constraint/spec.js",
    "src/cql.js",
    "src/enumerator.js",
    "src/enumspec.js",
    "src/enumspecindex.js",
    "src/generate.js",
    "src/model.js",
    "src/nest.js",
    "src/property.js",
    "src/query/encoding.js",
    "src/query/groupby.js",
    "src/query/query.js",
    "src/query/shorthand.js",
    "src/query/spec.js",
    "src/query/transform.js",
    "src/ranking/aggregation.js",
    "src/ranking/effectiveness/channel.js",
    "src/ranking/effectiveness/effectiveness.js",
    "src/ranking/effectiveness/mark.js",
    "src/ranking/effectiveness/type.js",
    "src/ranking/fieldorder.js",
    "src/ranking/ranking.js",
    "src/schema.js",
    "src/stylize.js",
    "src/util.js",
    "../vega-lite/node_modules/datalib/src/util.js",
    "../vega-lite/node_modules/json-stable-stringify/index.js",
    "../vega-lite/node_modules/jsonify/index.js",
    "../vega-lite/node_modules/jsonify/lib/parse.js",
    "../vega-lite/node_modules/jsonify/lib/stringify.js",
    "../vega-lite/src/aggregate.js",
    "../vega-lite/src/axis.js",
    "../vega-lite/src/bin.js",
    "../vega-lite/src/channel.js",
    "../vega-lite/src/datetime.js",
    "../vega-lite/src/encoding.js",
    "../vega-lite/src/mark.js",
    "../vega-lite/src/scale.js",
    "../vega-lite/src/sort.js",
    "../vega-lite/src/stack.js",
    "../vega-lite/src/timeunit.js",
    "../vega-lite/src/type.js",
    "../vega-lite/src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACz1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n",
    "var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the geometric mean of an array of numbers.\nstats.mean.geometric = function(values, f) {\n  f = util.$(f);\n  var mean = 1, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v <= 0) {\n        throw Error(\"Geometric mean only defined for positive values.\");\n      }\n      mean *= v;\n      ++c;\n    }\n  }\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\n  return mean;\n};\n\n// Compute the harmonic mean of an array of numbers.\nstats.mean.harmonic = function(values, f) {\n  f = util.$(f);\n  var mean = 0, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      mean += 1/v;\n      ++c;\n    }\n  }\n  return c / mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar mark_1 = require('vega-lite/src/mark');\nvar scale_1 = require('vega-lite/src/scale');\nvar sort_1 = require('vega-lite/src/sort');\nvar timeunit_1 = require('vega-lite/src/timeunit');\nvar type_1 = require('vega-lite/src/type');\nvar property_1 = require('./property');\nexports.DEFAULT_QUERY_CONFIG = {\n    verbose: false,\n    defaultSpecConfig: {\n        overlay: { line: true },\n        scale: { useRawDomain: true }\n    },\n    propertyPrecedence: property_1.DEFAULT_PROPERTY_PRECEDENCE,\n    marks: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TICK],\n    channels: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR],\n    aggregates: [undefined, aggregate_1.AggregateOp.MEAN],\n    timeUnits: [undefined, timeunit_1.TimeUnit.YEAR, timeunit_1.TimeUnit.MONTH, timeunit_1.TimeUnit.DATE, timeunit_1.TimeUnit.MINUTES, timeunit_1.TimeUnit.SECONDS],\n    types: [type_1.Type.NOMINAL, type_1.Type.ORDINAL, type_1.Type.QUANTITATIVE, type_1.Type.TEMPORAL],\n    maxBinsList: [5, 10, 20],\n    axisAxisColors: [undefined],\n    axisAxisWidths: [undefined],\n    axisLayers: ['front', 'back'],\n    axisOffsets: [undefined],\n    axisOrients: [undefined],\n    axisGridColors: [undefined],\n    axisGridDashes: [undefined],\n    axisGridOpacities: [undefined],\n    axisGridWidths: [undefined],\n    axisFormats: [undefined],\n    axisLabelAngles: [undefined],\n    axisLabelMaxLengths: [undefined],\n    axisSubDivides: [undefined],\n    axisTicks: [undefined],\n    axisTickColors: [undefined],\n    axisTickLabelColors: [undefined],\n    axisTickLabelFonts: [undefined],\n    axisTickLabelFontSizes: [undefined],\n    axisTickPaddings: [undefined],\n    axisTickSizes: [undefined],\n    axisTickSizeMajors: [undefined],\n    axisTickSizeMinors: [undefined],\n    axisTickSizeEnds: [undefined],\n    axisTickWidths: [undefined],\n    axisValuesList: [undefined],\n    axisTitles: [undefined],\n    axisTitleColors: [undefined],\n    axisTitleFonts: [undefined],\n    axisTitleFontWeights: [undefined],\n    axisTitleFontSizes: [undefined],\n    axisTitleOffsets: [undefined],\n    axisTitleMaxLengths: [undefined],\n    axisCharacterWidths: [undefined],\n    legendOrients: ['left', 'right'],\n    legendOffsets: [undefined],\n    legendValuesList: [undefined],\n    legendFormats: [undefined],\n    legendLabelAligns: [undefined],\n    legendLabelBaselines: [undefined],\n    legendLabelColors: [undefined],\n    legendLabelFonts: [undefined],\n    legendLabelFontSizes: [undefined],\n    legendSymbolColors: [undefined],\n    legendSymbolShapes: [undefined],\n    legendSymbolSizes: [undefined],\n    legendSymbolStrokeWidths: [undefined],\n    legendTitles: [undefined],\n    legendTitleColors: [undefined],\n    legendTitleFonts: [undefined],\n    legendTitleFontSizes: [undefined],\n    legendTitleFontWeights: [undefined],\n    // TODO: Come back and implement correctly when designing sort enumeration.\n    sorts: [sort_1.SortOrder.ASCENDING, sort_1.SortOrder.DESCENDING],\n    sortOps: [aggregate_1.AggregateOp.MIN, aggregate_1.AggregateOp.MEAN],\n    sortOrders: [sort_1.SortOrder.ASCENDING, sort_1.SortOrder.DESCENDING],\n    scaleBandSizes: [17, 21],\n    scaleDomains: [undefined],\n    scaleExponents: [1],\n    scaleRanges: [undefined],\n    scaleTypes: [undefined, scale_1.ScaleType.LOG],\n    numberNominalProportion: 0.05,\n    numberNominalLimit: 40,\n    // CONSTRAINTS\n    constraintManuallySpecifiedValue: false,\n    // Spec Constraints -- See description inside src/constraints/spec.ts\n    autoAddCount: false,\n    hasAppropriateGraphicTypeForMark: true,\n    omitAggregate: false,\n    omitAggregatePlotWithDimensionOnlyOnFacet: true,\n    omitAggregatePlotWithoutDimension: false,\n    omitBarLineAreaWithOcclusion: true,\n    omitBarTickWithSize: true,\n    omitMultipleNonPositionalChannels: true,\n    omitNonSumStack: true,\n    omitRaw: false,\n    omitRawContinuousFieldForAggregatePlot: true,\n    omitRepeatedField: true,\n    omitNonPositionalOrFacetOverPositionalChannels: true,\n    omitTableWithOcclusionIfAutoAddCount: true,\n    omitVerticalDotPlot: false,\n    preferredBinAxis: channel_1.Channel.X,\n    preferredTemporalAxis: channel_1.Channel.X,\n    preferredOrdinalAxis: channel_1.Channel.Y,\n    preferredNominalAxis: channel_1.Channel.Y,\n    preferredFacet: channel_1.Channel.ROW,\n    // Encoding Constraints -- See description inside src/constraints/encoding.ts\n    maxCardinalityForCategoricalColor: 20,\n    maxCardinalityForFacet: 20,\n    maxCardinalityForShape: 6,\n    timeUnitShouldHaveVariation: true,\n    typeMatchesSchemaType: true,\n    // STYLIZE\n    stylize: true,\n    smallBandSizeForHighCardinalityOrFacet: { maxCardinality: 10, bandSize: 12 },\n    nominalColorScaleForHighCardinality: { maxCardinality: 10, palette: 'category20' },\n    xAxisOnTopForHighYCardinalityWithoutColumn: { maxCardinality: 30 },\n    // RANKING PREFERENCE\n    maxGoodCardinalityForFacet: 5,\n    maxGoodCardinalityForColor: 7,\n};\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\n/**\n * Abstract model for a constraint.\n */\nvar AbstractConstraintModel = (function () {\n    function AbstractConstraintModel(constraint) {\n        this.constraint = constraint;\n    }\n    AbstractConstraintModel.prototype.name = function () {\n        return this.constraint.name;\n    };\n    AbstractConstraintModel.prototype.description = function () {\n        return this.constraint.description;\n    };\n    AbstractConstraintModel.prototype.properties = function () {\n        return this.constraint.properties;\n    };\n    AbstractConstraintModel.prototype.strict = function () {\n        return this.constraint.strict;\n    };\n    return AbstractConstraintModel;\n}());\nexports.AbstractConstraintModel = AbstractConstraintModel;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nvar _encoding = require('./encoding');\nvar _spec = require('./spec');\nexports.encoding = _encoding;\nexports.spec = _spec;\n//# sourceMappingURL=constraint.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar channel_1 = require('vega-lite/src/channel');\nvar scale_1 = require('vega-lite/src/scale');\nvar type_1 = require('vega-lite/src/type');\nvar base_1 = require('./base');\nvar property_1 = require('../property');\nvar enumspec_1 = require('../enumspec');\nvar schema_1 = require('../schema');\nvar util_1 = require('../util');\nvar encoding_1 = require('../query/encoding');\nvar EncodingConstraintModel = (function (_super) {\n    __extends(EncodingConstraintModel, _super);\n    function EncodingConstraintModel(constraint) {\n        _super.call(this, constraint);\n    }\n    EncodingConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (encQ) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            var nestedEncProp = property_1.getNestedEncodingProperty(prop);\n            if (nestedEncProp) {\n                var parent_1 = nestedEncProp.parent;\n                var child = nestedEncProp.child;\n                if (!encQ[parent_1]) {\n                    return true;\n                }\n                return !enumspec_1.isEnumSpec(encQ[parent_1][child]);\n            }\n            if (!encQ[prop]) {\n                return true;\n            }\n            return !enumspec_1.isEnumSpec(encQ[prop]);\n        });\n    };\n    EncodingConstraintModel.prototype.satisfy = function (encQ, schema, encEnumSpecIndex, opt) {\n        // TODO: Re-order logic to optimize the \"allowEnumSpecForProperties\" check\n        if (!this.constraint.allowEnumSpecForProperties) {\n            // TODO: extract as a method and do unit test\n            if (!this.hasAllRequiredPropertiesSpecific(encQ)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(encQ, schema, encEnumSpecIndex, opt);\n    };\n    return EncodingConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.EncodingConstraintModel = EncodingConstraintModel;\nexports.ENCODING_CONSTRAINTS = [\n    {\n        name: 'aggregateOpSupportedByType',\n        description: 'Aggregate function should be supported by data type.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.aggregate) {\n                return encQ.type !== type_1.Type.ORDINAL && encQ.type !== type_1.Type.NOMINAL;\n            }\n            // TODO: some aggregate function are actually supported by ordinal\n            return true; // no aggregate is okay with any type.\n        }\n    }, {\n        name: 'asteriskFieldWithCountOnly',\n        description: 'Field=\"*\" should be disallowed except aggregate=\"count\"',\n        properties: [property_1.Property.FIELD, property_1.Property.AGGREGATE],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            return (encQ.field === '*') === (encQ.aggregate === aggregate_1.AggregateOp.COUNT);\n        }\n    }, {\n        name: 'binAppliedForQuantitative',\n        description: 'bin should be applied to quantitative field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.BIN],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.bin) {\n                // If binned, the type must be quantitative\n                return encQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return true;\n        }\n    }, {\n        name: 'channelSupportsRole',\n        description: 'encoding channel should support the role of the field',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (enumspec_1.isEnumSpec(encQ.channel))\n                return true; // not ready for checking yet!\n            if (!encEnumSpecIndex.channel && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            var supportedRole = channel_1.getSupportedRole(encQ.channel);\n            if (encoding_1.isDimension(encQ)) {\n                return supportedRole.dimension;\n            }\n            else if (encoding_1.isMeasure(encQ)) {\n                return supportedRole.measure;\n            }\n            return true;\n        }\n    }, {\n        name: 'hasFn',\n        description: 'A field with as hasFn flag should have one of aggregate, timeUnit, or bin.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.hasFn) {\n                return !!encQ.aggregate || !!encQ.bin || !!encQ.timeUnit;\n            }\n            return true;\n        }\n    }, {\n        name: 'omitScaleZeroWithBinnedField',\n        description: 'Do not use scale zero with binned field',\n        properties: [property_1.Property.SCALE, property_1.Property.SCALE_ZERO, property_1.Property.BIN],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.bin && encQ.scale) {\n                if (encQ.scale.zero === true) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'onlyOneTypeOfFunction',\n        description: 'Only of of aggregate, autoCount, timeUnit, or bin should be applied at the same time.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            var numFn = (!enumspec_1.isEnumSpec(encQ.aggregate) && !!encQ.aggregate ? 1 : 0) +\n                (!enumspec_1.isEnumSpec(encQ.autoCount) && !!encQ.autoCount ? 1 : 0) +\n                (!enumspec_1.isEnumSpec(encQ.bin) && !!encQ.bin ? 1 : 0) +\n                (!enumspec_1.isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit ? 1 : 0);\n            return numFn <= 1;\n        }\n    }, {\n        name: 'timeUnitAppliedForTemporal',\n        description: 'Time unit should be applied to temporal field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.TIMEUNIT],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.timeUnit && encQ.type !== type_1.Type.TEMPORAL) {\n                return false;\n            }\n            return true;\n        }\n    }, {\n        name: 'timeUnitShouldHaveVariation',\n        description: 'A particular time unit should be applied only if they produce unique values.',\n        properties: [property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.timeUnit && encQ.type === type_1.Type.TEMPORAL) {\n                if (!encEnumSpecIndex.timeUnit && !opt.constraintManuallySpecifiedValue) {\n                    // Do not have to check this as this is manually specified by users.\n                    return true;\n                }\n                return schema.timeUnitHasVariation(encQ);\n            }\n            return true;\n        }\n    }, {\n        name: 'scalePropertiesSupportedByScaleType',\n        description: 'Scale properties must be supported by correct scale type',\n        properties: property_1.SCALE_PROPERTIES.concat([property_1.Property.SCALE, property_1.Property.TYPE]),\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.scale) {\n                var scale = encQ.scale;\n                //  If encQ.type is an EnumSpec and scale.type is undefined, it is equivalent\n                //  to scale type is EnumSpec. If scale type is an EnumSpec, we do not yet know\n                //  what the scale type is, and thus can ignore the constraint.\n                var sType = encoding_1.scaleType(encQ);\n                if (sType === undefined) {\n                    // If still ambiguous, doesn't check the constraint\n                    return true;\n                }\n                for (var scaleProp in scale) {\n                    if (property_1.SUPPORTED_SCALE_PROPERTY_INDEX[scaleProp]) {\n                        if (!util_1.contains(property_1.SUPPORTED_SCALE_PROPERTY_INDEX[scaleProp], sType)) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'typeMatchesPrimitiveType',\n        description: 'Data type should be supported by field\\'s primitive type.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.field === '*') {\n                return true;\n            }\n            var primitiveType = schema.primitiveType(encQ.field);\n            var type = encQ.type;\n            if (!encEnumSpecIndex.field && !encEnumSpecIndex.type && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            switch (primitiveType) {\n                case schema_1.PrimitiveType.BOOLEAN:\n                case schema_1.PrimitiveType.STRING:\n                    return type !== type_1.Type.QUANTITATIVE && type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.NUMBER:\n                case schema_1.PrimitiveType.INTEGER:\n                    return type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.DATE:\n                    // TODO: add NOMINAL, ORDINAL support after we support this in Vega-Lite\n                    return type === type_1.Type.TEMPORAL;\n                case null:\n                    // field does not exist in the schema\n                    return false;\n            }\n            throw new Error('Not implemented');\n        }\n    },\n    {\n        name: 'typeMatchesSchemaType',\n        description: 'Enumerated data type of a field should match the field\\'s type in the schema.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (!encEnumSpecIndex.field && !encEnumSpecIndex.type && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            if (encQ.field === '*') {\n                return encQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return schema.type(encQ.field) === encQ.type;\n        }\n    }, {\n        name: 'maxCardinalityForCategoricalColor',\n        description: 'Categorical channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            // TODO: missing case where ordinal / temporal use categorical color\n            // (once we do so, need to add Property.BIN, Property.TIMEUNIT)\n            if (encQ.channel === channel_1.Channel.COLOR && encQ.type === type_1.Type.NOMINAL) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForCategoricalColor;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForFacet',\n        description: 'Row/column channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForFacet;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForShape',\n        description: 'Shape channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.channel === channel_1.Channel.SHAPE) {\n                return schema.cardinality(encQ) <= opt.maxCardinalityForShape;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'dataTypeAndFunctionMatchScaleType',\n        description: 'Scale type must match data type',\n        properties: [property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (encQ, schema, encEnumSpecIndex, opt) {\n            if (encQ.scale) {\n                var type = encQ.type;\n                var sType = encoding_1.scaleType(encQ);\n                if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {\n                    return util_1.contains([scale_1.ScaleType.ORDINAL, undefined], sType);\n                }\n                else if (type === type_1.Type.TEMPORAL) {\n                    if (!encQ.timeUnit) {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.ORDINAL, undefined], sType);\n                    }\n                }\n                else if (type === type_1.Type.QUANTITATIVE) {\n                    if (encQ.bin) {\n                        return util_1.contains([scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n].map(function (ec) { return new EncodingConstraintModel(ec); });\nexports.ENCODING_CONSTRAINT_INDEX = exports.ENCODING_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nexports.ENCODING_CONSTRAINTS_BY_PROPERTY = exports.ENCODING_CONSTRAINTS.reduce(function (m, c) {\n    c.properties().forEach(function (prop) {\n        m[prop] = m[prop] || [];\n        m[prop].push(c);\n    });\n    return m;\n}, {});\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkEncoding(prop, enumSpec, index, specM, schema, opt) {\n    // Check encoding constraint\n    var encodingConstraints = exports.ENCODING_CONSTRAINTS_BY_PROPERTY[prop] || [];\n    var encQ = specM.getEncodingQueryByIndex(index);\n    for (var i = 0; i < encodingConstraints.length; i++) {\n        var c = encodingConstraints[i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, specM.enumSpecIndex.encodings[index], opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + enumSpec.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkEncoding = checkEncoding;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar scale_1 = require('vega-lite/src/scale');\nvar type_1 = require('vega-lite/src/type');\nvar base_1 = require('./base');\nvar enumspec_1 = require('../enumspec');\nvar property_1 = require('../property');\nvar encoding_1 = require('../query/encoding');\nvar util_1 = require('../util');\nvar encoding_2 = require('../query/encoding');\nvar NONSPATIAL_CHANNELS_INDEX = channel_1.NONSPATIAL_CHANNELS.reduce(function (m, channel) {\n    m[channel] = true;\n    return m;\n}, {});\nvar SpecConstraintModel = (function (_super) {\n    __extends(SpecConstraintModel, _super);\n    function SpecConstraintModel(specConstraint) {\n        _super.call(this, specConstraint);\n    }\n    SpecConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (specM) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            if (prop === property_1.Property.MARK) {\n                return !enumspec_1.isEnumSpec(specM.getMark());\n            }\n            // TODO: transform\n            var nestedEncProp = property_1.getNestedEncodingProperty(prop);\n            if (nestedEncProp) {\n                var parent_1 = nestedEncProp.parent;\n                var child_1 = nestedEncProp.child;\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (!encQ[parent_1]) {\n                        return true;\n                    }\n                    return !enumspec_1.isEnumSpec(encQ[parent_1][child_1]);\n                });\n            }\n            if (!property_1.isEncodingProperty(prop)) {\n                throw new Error('UNIMPLEMENTED');\n            }\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!encQ[prop]) {\n                    return true;\n                }\n                return !enumspec_1.isEnumSpec(encQ[prop]);\n            });\n        });\n    };\n    SpecConstraintModel.prototype.satisfy = function (specM, schema, opt) {\n        // TODO: Re-order logic to optimize the \"allowEnumSpecForProperties\" check\n        if (!this.constraint.allowEnumSpecForProperties) {\n            if (!this.hasAllRequiredPropertiesSpecific(specM)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(specM, schema, opt);\n    };\n    return SpecConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.SpecConstraintModel = SpecConstraintModel;\nexports.SPEC_CONSTRAINTS = [\n    {\n        name: 'noRepeatedChannel',\n        description: 'Each encoding channel should only be used once.',\n        properties: [property_1.Property.CHANNEL],\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var usedChannel = {};\n            // channel for all encodings should be valid\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!enumspec_1.isEnumSpec(encQ.channel)) {\n                    // If channel is specified, it should no be used already\n                    if (usedChannel[encQ.channel]) {\n                        return false;\n                    }\n                    usedChannel[encQ.channel] = true;\n                    return true;\n                }\n                return true; // unspecified channel is valid\n            });\n        }\n    },\n    {\n        name: 'alwaysIncludeZeroInScaleWithBarMark',\n        description: 'Do not recommend bar mark if scale does not start at zero',\n        properties: [property_1.Property.MARK, property_1.Property.SCALE, property_1.Property.SCALE_ZERO, property_1.Property.CHANNEL, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            if (mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_1 = encodings; _i < encodings_1.length; _i++) {\n                    var encQ = encodings_1[_i];\n                    if ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) &&\n                        (encQ.type === type_1.Type.QUANTITATIVE) &&\n                        (encQ.scale && encQ.scale.zero === false)) {\n                        // TODO: zero shouldn't be manually specified\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'autoAddCount',\n        description: 'Automatically adding count only for plots with only ordinal, binned quantitative, or temporal with timeunit fields.',\n        properties: [property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var hasAutoCount = util_1.some(specM.getEncodings(), function (encQ) { return encQ.autoCount === true; });\n            if (hasAutoCount) {\n                // Auto count should only be applied if all fields are nominal, ordinal, temporal with timeUnit, binned quantitative, or autoCount\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (encQ.autoCount !== undefined) {\n                        return true;\n                    }\n                    switch (encQ.type) {\n                        case type_1.Type.QUANTITATIVE:\n                            return !!encQ.bin;\n                        case type_1.Type.TEMPORAL:\n                            return !!encQ.timeUnit;\n                        case type_1.Type.ORDINAL:\n                        case type_1.Type.NOMINAL:\n                            return true;\n                    }\n                    /* istanbul ignore next */\n                    throw new Error('Unsupported Type');\n                });\n            }\n            else {\n                var neverHaveAutoCount = util_1.every(specM.enumSpecIndex.encodingIndicesByProperty['autoCount'], function (index) {\n                    return !enumspec_1.isEnumSpec(specM.getEncodingQueryByIndex(index).autoCount);\n                });\n                if (neverHaveAutoCount) {\n                    // If the query surely does not have autoCount\n                    // then one of the field should be\n                    // (1) unbinned quantitative\n                    // (2) temporal without time unit\n                    // (3) nominal or ordinal field\n                    // or at least have potential to be (still ambiguous).\n                    return util_1.some(specM.getEncodings(), function (encQ) {\n                        if (encQ.type === type_1.Type.QUANTITATIVE) {\n                            if (encQ.autoCount === false) {\n                                return false;\n                            }\n                            else {\n                                return !encQ.bin || enumspec_1.isEnumSpec(encQ.bin);\n                            }\n                        }\n                        else if (encQ.type === type_1.Type.TEMPORAL) {\n                            return !encQ.timeUnit || enumspec_1.isEnumSpec(encQ.timeUnit);\n                        }\n                        return false; // nominal or ordinal\n                    });\n                }\n            }\n            return true; // no auto count, no constraint\n        }\n    },\n    {\n        name: 'channelPermittedByMarkType',\n        description: 'Each encoding channel should be supported by the mark type',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowEnumSpecForProperties: true,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            // if mark is unspecified, no need to check\n            if (enumspec_1.isEnumSpec(mark))\n                return true;\n            // TODO: can optimize this to detect only what's the changed property if needed.\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                // channel unspecified, no need to check\n                if (enumspec_1.isEnumSpec(encQ.channel))\n                    return true;\n                return channel_1.supportMark(encQ.channel, mark);\n            });\n        }\n    },\n    {\n        name: 'hasAllRequiredChannelsForMark',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    return specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.TEXT:\n                    return specM.channelUsed(channel_1.Channel.TEXT);\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.TICK:\n                case mark_1.Mark.RULE:\n                    return specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.POINT:\n                    // This allows generating a point plot if channel was not an enum spec.\n                    return !specM.enumSpecIndex.hasProperty(property_1.Property.CHANNEL) ||\n                        specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitAggregate',\n        description: 'Omit aggregate plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithDimensionOnlyOnFacet',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                var hasNonFacetDim_1 = false, hasDim_1 = false, hasEnumeratedFacetDim_1 = false;\n                specM.specQuery.encodings.forEach(function (encQ, index) {\n                    if (encQ.autoCount === false)\n                        return; // skip unused field\n                    if (!encQ.aggregate && !encQ.autoCount) {\n                        hasDim_1 = true;\n                        if (util_1.contains([channel_1.Channel.ROW, channel_1.Channel.COLUMN], encQ.channel)) {\n                            if (specM.enumSpecIndex.hasEncodingProperty(index, property_1.Property.CHANNEL)) {\n                                hasEnumeratedFacetDim_1 = true;\n                            }\n                        }\n                        else {\n                            hasNonFacetDim_1 = true;\n                        }\n                    }\n                });\n                if (hasDim_1 && !hasNonFacetDim_1) {\n                    if (hasEnumeratedFacetDim_1 || opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithoutDimension',\n        description: 'Aggregate plots without dimension should be omitted',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                // TODO relax\n                return util_1.some(specM.getEncodings(), function (encQ) {\n                    if (encoding_1.isDimension(encQ)) {\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            return true;\n        }\n    },\n    {\n        // TODO: we can be smarter and check if bar has occlusion based on profiling statistics\n        name: 'omitBarLineAreaWithOcclusion',\n        description: 'Don\\'t use bar, line or area to visualize raw plot as they often lead to occlusion.',\n        properties: [property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (util_1.contains([mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA], specM.getMark())) {\n                return specM.isAggregate();\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitBarTickWithSize',\n        description: 'Do not map field to size channel with bar and tick mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            if (util_1.contains([mark_1.Mark.TICK, mark_1.Mark.BAR], mark)) {\n                if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                    if (opt.constraintManuallySpecifiedValue) {\n                        // If size is used and we constraintManuallySpecifiedValue,\n                        // then the spec violates this constraint.\n                        return false;\n                    }\n                    else {\n                        // Otherwise have to search for the size channel and check if it is enumerated\n                        var encodings = specM.specQuery.encodings;\n                        for (var i = 0; i < encodings.length; i++) {\n                            var encQ = encodings[i];\n                            if (encQ.channel === channel_1.Channel.SIZE) {\n                                if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                                    // If enumerated, then this is bad\n                                    return false;\n                                }\n                                else {\n                                    // If it's manually specified, no need to continue searching, just return.\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return true; // skip\n        }\n    },\n    {\n        name: 'omitBarAreaForLogScale',\n        description: 'Do not use bar and area mark for x and y\\'s log scale',\n        properties: [property_1.Property.MARK, property_1.Property.CHANNEL, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TYPE],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            // TODO: mark or scale type should be enumerated\n            if (mark === mark_1.Mark.AREA || mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_2 = encodings; _i < encodings_2.length; _i++) {\n                    var encQ = encodings_2[_i];\n                    if ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) && encQ.scale) {\n                        var sType = encoding_2.scaleType(encQ);\n                        if (sType === scale_1.ScaleType.LOG) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitMultipleNonPositionalChannels',\n        description: 'Unless manually specified, do not use multiple non-positional encoding channel to avoid over-encoding.',\n        properties: [property_1.Property.CHANNEL],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            // have to use specM.specQuery.encodings insetad of specM.getEncodings()\n            // since specM.getEncodings() remove encQ with autoCount===false from the array\n            // and thus might shift the index\n            var encodings = specM.specQuery.encodings;\n            var nonPositionChannelCount = 0;\n            var hasEnumeratedNonPositionChannel = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encQ.autoCount === false)\n                    continue; // ignore skipped encoding\n                var channel = encQ.channel;\n                if (!enumspec_1.isEnumSpec(channel)) {\n                    if (NONSPATIAL_CHANNELS_INDEX[channel]) {\n                        nonPositionChannelCount += 1;\n                        if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                            hasEnumeratedNonPositionChannel = true;\n                        }\n                        if (nonPositionChannelCount > 1 &&\n                            (hasEnumeratedNonPositionChannel || opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonPositionalOrFacetOverPositionalChannels',\n        description: 'Do not use non-positional channels unless all positional channels are used',\n        properties: [property_1.Property.CHANNEL],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var encodings = specM.specQuery.encodings;\n            var hasNonPositionalChannelOrFacet = false;\n            var hasEnumeratedNonPositionOrFacetChannel = false;\n            var hasX = false, hasY = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encQ.autoCount === false)\n                    continue; // ignore skipped encoding\n                var channel = encQ.channel;\n                if (channel === channel_1.Channel.X) {\n                    hasX = true;\n                }\n                else if (channel === channel_1.Channel.Y) {\n                    hasY = true;\n                }\n                else if (!enumspec_1.isEnumSpec(channel)) {\n                    // All non positional channel / Facet\n                    hasNonPositionalChannelOrFacet = true;\n                    if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                        hasEnumeratedNonPositionOrFacetChannel = true;\n                    }\n                }\n            }\n            if (hasEnumeratedNonPositionOrFacetChannel ||\n                (opt.constraintManuallySpecifiedValue && hasNonPositionalChannelOrFacet)) {\n                return hasX && hasY;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRaw',\n        description: 'Omit raw plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (!specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawContinuousFieldForAggregatePlot',\n        description: 'Aggregate plot should not use raw continuous field as group by values. ' +\n            '(Quantitative should be binned. Temporal should have time unit.)',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.TYPE],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                var encodings = specM.specQuery.encodings;\n                for (var i = 0; i < encodings.length; i++) {\n                    var encQ = encodings[i];\n                    if (encQ.autoCount === false)\n                        continue; // skip unused encoding\n                    // TODO: aggregate for ordinal and temporal\n                    if (encQ.type === type_1.Type.TEMPORAL) {\n                        // Temporal fields should have timeUnit or is still an enumSpec\n                        if (!encQ.timeUnit && (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.TIMEUNIT) ||\n                            opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                    if (encQ.type === type_1.Type.QUANTITATIVE) {\n                        if (!encQ.bin && !encQ.aggregate && !encQ.autoCount) {\n                            // If Raw Q\n                            if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.BIN) ||\n                                specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.AGGREGATE) ||\n                                specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.AUTOCOUNT)) {\n                                // and it's raw from enumeration\n                                return false;\n                            }\n                            if (opt.constraintManuallySpecifiedValue) {\n                                // or if we constraintManuallySpecifiedValue\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawDetail',\n        description: 'Do not use detail channel with raw plot.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            if (specM.isAggregate()) {\n                return true;\n            }\n            return util_1.every(specM.specQuery.encodings, function (encQ, index) {\n                if (encQ.autoCount === false)\n                    return true; // ignore autoCount field\n                if (encQ.channel === channel_1.Channel.DETAIL) {\n                    // Detail channel for raw plot is not good, except when its enumerated\n                    // or when it's manually specified but we constraintManuallySpecifiedValue.\n                    if (specM.enumSpecIndex.hasEncodingProperty(index, property_1.Property.CHANNEL) ||\n                        opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    },\n    {\n        name: 'omitRepeatedField',\n        description: 'Each field should be mapped to only one channel',\n        properties: [property_1.Property.FIELD],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var fieldUsed = {};\n            var fieldEnumerated = {};\n            var encodings = specM.specQuery.encodings;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encQ.field && !enumspec_1.isEnumSpec(encQ.field)) {\n                    var field = encQ.field;\n                    if (specM.enumSpecIndex.hasEncodingProperty(i, property_1.Property.FIELD)) {\n                        fieldEnumerated[field] = true;\n                    }\n                    // When the field is specified previously,\n                    // if it is enumerated (either previously or in this encQ)\n                    // or if the opt.constraintManuallySpecifiedValue is true,\n                    // then it violates the constraint.\n                    if (fieldUsed[field]) {\n                        if (fieldEnumerated[field] || opt.constraintManuallySpecifiedValue) {\n                            return false;\n                        }\n                    }\n                    fieldUsed[field] = true;\n                }\n            }\n            return true;\n        }\n    },\n    // TODO: omitShapeWithBin\n    {\n        name: 'omitVerticalDotPlot',\n        description: 'Do not output vertical dot plot.',\n        properties: [property_1.Property.CHANNEL],\n        allowEnumSpecForProperties: true,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var encodings = specM.getEncodings();\n            if (encodings.length === 1 && encodings[0].channel === channel_1.Channel.Y) {\n                return false;\n            }\n            return true;\n        }\n    },\n    // EXPENSIVE CONSTRAINTS -- check them later!\n    {\n        name: 'hasAppropriateGraphicTypeForMark',\n        description: 'Has appropriate graphic type for mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    if (specM.isAggregate()) {\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsMeasure = xEncQ && encoding_2.isMeasure(xEncQ);\n                        var yIsMeasure = yEncQ && encoding_2.isMeasure(yEncQ);\n                        // for aggregate line / area, we need at least one group-by axis and one measure axis.\n                        return xEncQ && yEncQ && (xIsMeasure !== yIsMeasure) &&\n                            // and the dimension axis should not be nominal\n                            // TODO: make this clause optional\n                            !(!xIsMeasure && xEncQ.type === type_1.Type.NOMINAL) &&\n                            !(!yIsMeasure && yEncQ.type === type_1.Type.NOMINAL);\n                    }\n                    return true;\n                case mark_1.Mark.TEXT:\n                    // FIXME correctly when we add text\n                    return true;\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.TICK:\n                    // Bar and tick should not use size.\n                    if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                        return false;\n                    }\n                    // Tick and Bar should have one and only one measure\n                    if (specM.isMeasure(channel_1.Channel.X) !== specM.isMeasure(channel_1.Channel.Y)) {\n                        // TODO: Bar and tick's dimension should not be continuous (quant/time) scale\n                        return true;\n                    }\n                    return false;\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.POINT:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.RULE:\n                    return true;\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitNonLinearScaleTypeWithStack',\n        description: 'Stacked plot should only use linear scale',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.SCALE, property_1.Property.SCALE_TYPE, property_1.Property.TYPE],\n        // TODO: Property.STACK\n        allowEnumSpecForProperties: false,\n        strict: true,\n        satisfy: function (specM, schema, opt) {\n            var stack = specM.stack();\n            if (stack) {\n                for (var _i = 0, _a = specM.getEncodings(); _i < _a.length; _i++) {\n                    var encQ = _a[_i];\n                    if ((!!encQ.aggregate || encQ.autoCount === true) &&\n                        encQ.type === type_1.Type.QUANTITATIVE &&\n                        util_1.contains([channel_1.Channel.X, channel_1.Channel.Y], encQ.channel)) {\n                        if (encoding_2.scaleType(encQ) !== scale_1.ScaleType.LINEAR) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonSumStack',\n        description: 'Stacked plot should use summative aggregation such as sum, count, or distinct',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            var stack = specM.stack();\n            if (stack) {\n                var measureEncQ = specM.getEncodingQueryByChannel(stack.fieldChannel);\n                return util_1.contains(aggregate_1.SUM_OPS, measureEncQ.aggregate) || !!measureEncQ.autoCount;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitTableWithOcclusionIfAutoAddCount',\n        description: 'Plots without aggregation or autocount where x and y are both dimensions should be omitted if autoAddCount is enabled as they often lead to occlusion',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowEnumSpecForProperties: false,\n        strict: false,\n        satisfy: function (specM, schema, opt) {\n            if (opt.autoAddCount) {\n                // TODO(#186): take mark properties channel into account\n                if (specM.isDimension(channel_1.Channel.X) &&\n                    specM.isDimension(channel_1.Channel.Y) &&\n                    !specM.isAggregate() // TODO: refactor based on statistics\n                ) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n].map(function (sc) { return new SpecConstraintModel(sc); });\n// For testing\nexports.SPEC_CONSTRAINT_INDEX = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    m[c.name()] = c;\n    return m;\n}, {});\n//\nexports.SPEC_CONSTRAINTS_BY_PROPERTY = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    c.properties().forEach(function (prop) {\n        m[prop] = m[prop] || [];\n        m[prop].push(c);\n    });\n    return m;\n}, {});\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkSpec(prop, enumSpec, specM, schema, opt) {\n    // Check encoding constraint\n    var specConstraints = exports.SPEC_CONSTRAINTS_BY_PROPERTY[prop] || [];\n    for (var i = 0; i < specConstraints.length; i++) {\n        var c = specConstraints[i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(specM, schema, opt);\n            if (!satisfy) {\n                var violatedConstraint = '(spec) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + enumSpec.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkSpec = checkSpec;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nexports.version = '0.6.7';\nvar util_1 = require('./util');\nexports.config = require('./config');\nexports.constraint = require('./constraint/constraint');\nexports.enumerate = require('./enumerator');\nexports.enumSpec = require('./enumspec');\nvar generate_1 = require('./generate');\nexports.generate = generate_1.generate;\nexports.model = require('./model');\nexports.nest = require('./nest');\nexports.property = require('./property');\n// Make it so that we can call cql.query() as method, or access other methods inside cql.query\nvar cqlQuery = require('./query/query');\nvar query_1 = require('./query/query');\nexports.query = util_1.extend(query_1.query, cqlQuery);\nexports.ranking = require('./ranking/ranking');\nexports.schema = require('./schema');\nexports.util = require('./util');\n//# sourceMappingURL=cql.js.map",
    "\"use strict\";\nvar encoding_1 = require('./constraint/encoding');\nvar spec_1 = require('./constraint/spec');\nvar property_1 = require('./property');\nexports.ENUMERATOR_INDEX = {};\nexports.ENUMERATOR_INDEX[property_1.Property.MARK] = function (enumSpecIndex, schema, opt) {\n    return function (answerSet, specM) {\n        var markEnumSpec = specM.getMark();\n        // enumerate the value\n        markEnumSpec.enum.forEach(function (mark) {\n            specM.setMark(mark);\n            // Check spec constraint\n            var violatedSpecConstraint = spec_1.checkSpec(property_1.Property.MARK, enumSpecIndex.mark, specM, schema, opt);\n            if (!violatedSpecConstraint) {\n                // emit\n                answerSet.push(specM.duplicate());\n            }\n        });\n        // Reset to avoid side effect\n        specM.resetMark();\n        return answerSet;\n    };\n};\nproperty_1.ENCODING_PROPERTIES.forEach(function (prop) {\n    exports.ENUMERATOR_INDEX[prop] = EncodingPropertyGeneratorFactory(prop);\n});\nproperty_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\n    exports.ENUMERATOR_INDEX[nestedProp.property] = EncodingPropertyGeneratorFactory(nestedProp.property);\n});\n/**\n * @param prop property type.\n * @return an answer set reducer factory for the given prop.\n */\nfunction EncodingPropertyGeneratorFactory(prop) {\n    /**\n     * @return as reducer that takes a specQueryModel as input and output an answer set array.\n     */\n    return function (enumSpecIndex, schema, opt) {\n        return function (answerSet, specM) {\n            // index of encoding mappings that require enumeration\n            var indices = enumSpecIndex.encodingIndicesByProperty[prop];\n            function enumerate(jobIndex) {\n                if (jobIndex === indices.length) {\n                    // emit and terminate\n                    answerSet.push(specM.duplicate());\n                    return;\n                }\n                var index = indices[jobIndex];\n                var enumSpec = enumSpecIndex.encodings[index][prop];\n                var encQ = specM.getEncodingQueryByIndex(index);\n                var propEnumSpec = specM.getEncodingProperty(index, prop);\n                if (\n                // TODO: encQ.exclude\n                // If this encoding query is an excluded autoCount, there is no point enumerating other properties\n                // for this encoding query because they will be excluded anyway.\n                // Thus, we can just move on to the next encoding to enumerate.\n                encQ.autoCount === false ||\n                    // nested encoding property might have its parent set to false\n                    // therefore, we no longer have to enumerate them\n                    !propEnumSpec) {\n                    enumerate(jobIndex + 1);\n                }\n                else {\n                    enumSpec.enum.forEach(function (propVal) {\n                        if (propVal === null) {\n                            // our duplicate() method use JSON.stringify, parse and thus can accidentally\n                            // convert undefined in an array into null\n                            propVal = undefined;\n                        }\n                        specM.setEncodingProperty(index, prop, propVal, enumSpec);\n                        // Check encoding constraint\n                        var violatedEncodingConstraint = encoding_1.checkEncoding(prop, enumSpec, index, specM, schema, opt);\n                        if (violatedEncodingConstraint) {\n                            return; // do not keep searching\n                        }\n                        // Check spec constraint\n                        var violatedSpecConstraint = spec_1.checkSpec(prop, enumSpec, specM, schema, opt);\n                        if (violatedSpecConstraint) {\n                            return; // do not keep searching\n                        }\n                        // If qualify all of the constraints, keep enumerating\n                        enumerate(jobIndex + 1);\n                    });\n                    // Reset to avoid side effect\n                    specM.resetEncodingProperty(index, prop, enumSpec);\n                }\n            }\n            // start enumerating from 0\n            enumerate(0);\n            return answerSet;\n        };\n    };\n}\nexports.EncodingPropertyGeneratorFactory = EncodingPropertyGeneratorFactory;\n//# sourceMappingURL=enumerator.js.map",
    "\"use strict\";\nvar util_1 = require('./util');\n/** Enum for a short form of the enumeration spec. */\n(function (ShortEnumSpec) {\n    ShortEnumSpec[ShortEnumSpec[\"ENUMSPEC\"] = '?'] = \"ENUMSPEC\";\n})(exports.ShortEnumSpec || (exports.ShortEnumSpec = {}));\nvar ShortEnumSpec = exports.ShortEnumSpec;\nexports.SHORT_ENUM_SPEC = ShortEnumSpec.ENUMSPEC;\nfunction isEnumSpec(prop) {\n    return prop === exports.SHORT_ENUM_SPEC || (prop !== undefined && (!!prop.enum || !!prop.name) && !util_1.isArray(prop));\n}\nexports.isEnumSpec = isEnumSpec;\nfunction initEnumSpec(prop, defaultName, defaultEnumValues) {\n    return util_1.extend({}, {\n        name: defaultName,\n        enum: defaultEnumValues\n    }, prop === exports.SHORT_ENUM_SPEC ? {} : prop);\n}\nexports.initEnumSpec = initEnumSpec;\n//# sourceMappingURL=enumspec.js.map",
    "\"use strict\";\nvar property_1 = require('./property');\nvar util_1 = require('./util');\nvar EnumSpecIndex = (function () {\n    function EnumSpecIndex() {\n        this._mark = undefined;\n        this._encodings = {};\n        this._encodingIndicesByProperty = {};\n    }\n    EnumSpecIndex.prototype.setEncodingProperty = function (index, prop, enumSpec) {\n        var encodingsIndex = this._encodings;\n        // Init encoding index and set prop\n        var encIndex = encodingsIndex[index] = encodingsIndex[index] || {};\n        encIndex[prop] = enumSpec;\n        // Initialize indicesByProperty[prop] and add index\n        var encodingIndicesByProperty = this._encodingIndicesByProperty;\n        (encodingIndicesByProperty[prop] = encodingIndicesByProperty[prop] || []).push(index);\n        return this;\n    };\n    EnumSpecIndex.prototype.hasEncodingProperty = function (index, prop) {\n        return !!(this._encodings[index] || {})[prop];\n    };\n    EnumSpecIndex.prototype.hasProperty = function (prop) {\n        if (property_1.isEncodingProperty(prop)) {\n            return !!this.encodingIndicesByProperty[prop];\n        }\n        if (prop === property_1.Property.MARK) {\n            return !!this.mark;\n        }\n        /* istanbul ignore next */\n        throw new Error('Unimplemented for property ' + prop);\n    };\n    EnumSpecIndex.prototype.isEmpty = function () {\n        return !this.mark && util_1.keys(this.encodingIndicesByProperty).length === 0;\n    };\n    EnumSpecIndex.prototype.setMark = function (mark) {\n        this._mark = mark;\n        return this;\n    };\n    Object.defineProperty(EnumSpecIndex.prototype, \"mark\", {\n        get: function () {\n            return this._mark;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EnumSpecIndex.prototype, \"encodings\", {\n        get: function () {\n            return this._encodings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EnumSpecIndex.prototype, \"encodingIndicesByProperty\", {\n        get: function () {\n            return this._encodingIndicesByProperty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EnumSpecIndex;\n}());\nexports.EnumSpecIndex = EnumSpecIndex;\n//# sourceMappingURL=enumspecindex.js.map",
    "\"use strict\";\nvar enumerator_1 = require('../src/enumerator');\nvar config_1 = require('./config');\nvar model_1 = require('./model');\nvar stylize_1 = require('./stylize');\nfunction generate(specQ, schema, opt) {\n    if (opt === void 0) { opt = config_1.DEFAULT_QUERY_CONFIG; }\n    // 1. Build a SpecQueryModel, which also contains enumSpecIndex\n    var specM = model_1.SpecQueryModel.build(specQ, schema, opt);\n    var enumSpecIndex = specM.enumSpecIndex;\n    // 2. Enumerate each of the properties based on propPrecedence.\n    var answerSet = [specM]; // Initialize Answer Set with only the input spec query.\n    opt.propertyPrecedence.forEach(function (prop) {\n        // If the original specQuery contains enumSpec for this prop\n        if (enumSpecIndex.hasProperty(prop)) {\n            // update answerset\n            var reducer = enumerator_1.ENUMERATOR_INDEX[prop](enumSpecIndex, schema, opt);\n            answerSet = answerSet.reduce(reducer, []);\n        }\n    });\n    if (opt.stylize) {\n        if ((opt.nominalColorScaleForHighCardinality !== null) ||\n            (opt.smallBandSizeForHighCardinalityOrFacet !== null) ||\n            (opt.xAxisOnTopForHighYCardinalityWithoutColumn !== null)) {\n            return stylize_1.stylize(answerSet, schema, opt);\n        }\n    }\n    return answerSet;\n}\nexports.generate = generate;\n//# sourceMappingURL=generate.js.map",
    "\"use strict\";\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar type_1 = require('vega-lite/src/type');\nvar property_1 = require('./property');\nvar enumspec_1 = require('./enumspec');\nvar enumspecindex_1 = require('./enumspecindex');\nvar spec_1 = require('./query/spec');\nvar encoding_1 = require('./query/encoding');\nvar groupby_1 = require('./query/groupby');\nvar shorthand_1 = require('./query/shorthand');\nvar util_1 = require('./util');\nfunction getDefaultName(prop) {\n    switch (prop) {\n        case property_1.Property.MARK:\n            return 'm';\n        case property_1.Property.CHANNEL:\n            return 'c';\n        case property_1.Property.AGGREGATE:\n            return 'a';\n        case property_1.Property.AUTOCOUNT:\n            return '#';\n        case property_1.Property.BIN:\n            return 'b';\n        case property_1.Property.BIN_MAXBINS:\n            return 'b-mb';\n        case property_1.Property.SORT:\n            return 'so';\n        case property_1.Property.SORT_FIELD:\n            return 'so-f';\n        case property_1.Property.SORT_OP:\n            return 'so-op';\n        case property_1.Property.SORT_ORDER:\n            return 'so-or';\n        case property_1.Property.SCALE:\n            return 's';\n        case property_1.Property.SCALE_BANDSIZE:\n            return 's-bs';\n        case property_1.Property.SCALE_CLAMP:\n            return 's-c';\n        case property_1.Property.SCALE_DOMAIN:\n            return 's-d';\n        case property_1.Property.SCALE_EXPONENT:\n            return 's-e';\n        case property_1.Property.SCALE_NICE:\n            return 's-n';\n        case property_1.Property.SCALE_RANGE:\n            return 's-ra';\n        case property_1.Property.SCALE_ROUND:\n            return 's-r';\n        case property_1.Property.SCALE_TYPE:\n            return 's-t';\n        case property_1.Property.SCALE_USERAWDOMAIN:\n            return 's-u';\n        case property_1.Property.SCALE_ZERO:\n            return 's-z';\n        case property_1.Property.AXIS:\n            return 'ax';\n        case property_1.Property.AXIS_AXISCOLOR:\n            return 'ax-ac';\n        case property_1.Property.AXIS_AXISWIDTH:\n            return 'ax-aw';\n        case property_1.Property.AXIS_LAYER:\n            return 'ax-lay';\n        case property_1.Property.AXIS_OFFSET:\n            return 'ax-of';\n        case property_1.Property.AXIS_ORIENT:\n            return 'ax-or';\n        case property_1.Property.AXIS_GRID:\n            return 'ax-g';\n        case property_1.Property.AXIS_GRIDCOLOR:\n            return 'ax-gc';\n        case property_1.Property.AXIS_GRIDDASH:\n            return 'ax-gd';\n        case property_1.Property.AXIS_GRIDOPACITY:\n            return 'ax-go';\n        case property_1.Property.AXIS_GRIDWIDTH:\n            return 'ax-gw';\n        case property_1.Property.AXIS_LABELS:\n            return 'ax-lab';\n        case property_1.Property.AXIS_FORMAT:\n            return 'ax-f';\n        case property_1.Property.AXIS_LABELANGLE:\n            return 'ax-laba';\n        case property_1.Property.AXIS_LABELMAXLENGTH:\n            return 'ax-labm';\n        case property_1.Property.AXIS_SHORTTIMELABELS:\n            return 'ax-stl';\n        case property_1.Property.AXIS_SUBDIVIDE:\n            return 'ax-sub';\n        case property_1.Property.AXIS_TICKS:\n            return 'ax-t';\n        case property_1.Property.AXIS_TICKCOLOR:\n            return 'ax-tc';\n        case property_1.Property.AXIS_TICKLABELCOLOR:\n            return 'ax-tlc';\n        case property_1.Property.AXIS_TICKLABELFONT:\n            return 'ax-tlf';\n        case property_1.Property.AXIS_TICKLABELFONTSIZE:\n            return 'ax-tlfs';\n        case property_1.Property.AXIS_TICKPADDING:\n            return 'ax-tp';\n        case property_1.Property.AXIS_TICKSIZE:\n            return 'ax-ts';\n        case property_1.Property.AXIS_TICKSIZEMAJOR:\n            return 'ax-tsma';\n        case property_1.Property.AXIS_TICKSIZEMINOR:\n            return 'ax-tsmi';\n        case property_1.Property.AXIS_TICKSIZEEND:\n            return 'ax-tse';\n        case property_1.Property.AXIS_TICKWIDTH:\n            return 'ax-tw';\n        case property_1.Property.AXIS_VALUES:\n            return 'ax-v';\n        case property_1.Property.AXIS_TITLE:\n            return 'ax-ti';\n        case property_1.Property.AXIS_TITLECOLOR:\n            return 'ax-tic';\n        case property_1.Property.AXIS_TITLEFONT:\n            return 'ax-tif';\n        case property_1.Property.AXIS_TITLEFONTSIZE:\n            return 'ax-tifs';\n        case property_1.Property.AXIS_TITLEFONTWEIGHT:\n            return 'ax-tifw';\n        case property_1.Property.AXIS_TITLEOFFSET:\n            return 'ax-tio';\n        case property_1.Property.AXIS_TITLEMAXLENGTH:\n            return 'ax-timl';\n        case property_1.Property.AXIS_CHARACTERWIDTH:\n            return 'ax-cw';\n        case property_1.Property.LEGEND:\n            return 'l';\n        case property_1.Property.LEGEND_ORIENT:\n            return 'l-or';\n        case property_1.Property.LEGEND_OFFSET:\n            return 'l-of';\n        case property_1.Property.LEGEND_VALUES:\n            return 'l-v';\n        case property_1.Property.LEGEND_FORMAT:\n            return 'l-f';\n        case property_1.Property.LEGEND_LABELALIGN:\n            return 'l-la';\n        case property_1.Property.LEGEND_LABELBASELINE:\n            return 'l-lb';\n        case property_1.Property.LEGEND_LABELCOLOR:\n            return 'l-lc';\n        case property_1.Property.LEGEND_LABELFONT:\n            return 'l-lf';\n        case property_1.Property.LEGEND_LABELFONTSIZE:\n            return 'l-lfs';\n        case property_1.Property.LEGEND_SHORTTIMELABELS:\n            return 'l-stl';\n        case property_1.Property.LEGEND_SYMBOLCOLOR:\n            return 'l-syc';\n        case property_1.Property.LEGEND_SYMBOLSHAPE:\n            return 'l-sysh';\n        case property_1.Property.LEGEND_SYMBOLSIZE:\n            return 'l-sysi';\n        case property_1.Property.LEGEND_SYMBOLSTROKEWIDTH:\n            return 'l-sysw';\n        case property_1.Property.LEGEND_TITLE:\n            return 'l-ti';\n        case property_1.Property.LEGEND_TITLECOLOR:\n            return 'l-tic';\n        case property_1.Property.LEGEND_TITLEFONT:\n            return 'l-tif';\n        case property_1.Property.LEGEND_TITLEFONTSIZE:\n            return 'l-tifs';\n        case property_1.Property.LEGEND_TITLEFONTWEIGHT:\n            return 'l-tifw';\n        case property_1.Property.TIMEUNIT:\n            return 'tu';\n        case property_1.Property.FIELD:\n            return 'f';\n        case property_1.Property.TYPE:\n            return 't';\n    }\n    /* istanbul ignore next */\n    throw new Error('Default name undefined');\n}\nexports.getDefaultName = getDefaultName;\nfunction getDefaultEnumValues(prop, schema, opt) {\n    switch (prop) {\n        case property_1.Property.FIELD: // For field, by default enumerate all fields\n        case property_1.Property.SORT_FIELD:\n            return schema.fields();\n        // True, False for boolean values\n        case property_1.Property.AXIS:\n        case property_1.Property.AXIS_GRID:\n        case property_1.Property.AXIS_LABELS:\n        case property_1.Property.AXIS_SHORTTIMELABELS:\n        case property_1.Property.BIN:\n        case property_1.Property.LEGEND:\n        case property_1.Property.LEGEND_SHORTTIMELABELS:\n        case property_1.Property.SCALE:\n        case property_1.Property.SCALE_CLAMP:\n        case property_1.Property.SCALE_NICE:\n        case property_1.Property.SCALE_ROUND:\n        case property_1.Property.SCALE_USERAWDOMAIN:\n        case property_1.Property.SCALE_ZERO:\n        case property_1.Property.AUTOCOUNT:\n            return [false, true];\n        // For other properties, take default enumValues from config.\n        // The config name for each prop is a plural form of the prop.\n        case property_1.Property.AGGREGATE:\n            return opt.aggregates;\n        case property_1.Property.AXIS_AXISCOLOR:\n            return opt.axisAxisColors;\n        case property_1.Property.AXIS_AXISWIDTH:\n            return opt.axisAxisWidths;\n        case property_1.Property.AXIS_LAYER:\n            return opt.axisLayers;\n        case property_1.Property.AXIS_OFFSET:\n            return opt.axisOffsets;\n        case property_1.Property.AXIS_ORIENT:\n            return opt.axisOrients;\n        case property_1.Property.AXIS_GRIDCOLOR:\n            return opt.axisGridColors;\n        case property_1.Property.AXIS_GRIDDASH:\n            return opt.axisGridDashes;\n        case property_1.Property.AXIS_GRIDOPACITY:\n            return opt.axisGridOpacities;\n        case property_1.Property.AXIS_GRIDWIDTH:\n            return opt.axisGridWidths;\n        case property_1.Property.AXIS_FORMAT:\n            return opt.axisFormats;\n        case property_1.Property.AXIS_LABELANGLE:\n            return opt.axisLabelAngles;\n        case property_1.Property.AXIS_LABELMAXLENGTH:\n            return opt.axisLabelMaxLengths;\n        case property_1.Property.AXIS_SUBDIVIDE:\n            return opt.axisSubDivides;\n        case property_1.Property.AXIS_TICKS:\n            return opt.axisTicks;\n        case property_1.Property.AXIS_TICKCOLOR:\n            return opt.axisTickColors;\n        case property_1.Property.AXIS_TICKLABELCOLOR:\n            return opt.axisTickLabelColors;\n        case property_1.Property.AXIS_TICKLABELFONT:\n            return opt.axisTickLabelFonts;\n        case property_1.Property.AXIS_TICKLABELFONTSIZE:\n            return opt.axisTickLabelFontSizes;\n        case property_1.Property.AXIS_TICKPADDING:\n            return opt.axisTickPaddings;\n        case property_1.Property.AXIS_TICKSIZE:\n            return opt.axisTickSizes;\n        case property_1.Property.AXIS_TICKSIZEMAJOR:\n            return opt.axisTickSizeMajors;\n        case property_1.Property.AXIS_TICKSIZEMINOR:\n            return opt.axisTickSizeMinors;\n        case property_1.Property.AXIS_TICKSIZEEND:\n            return opt.axisTickSizeEnds;\n        case property_1.Property.AXIS_TICKWIDTH:\n            return opt.axisTickWidths;\n        case property_1.Property.AXIS_VALUES:\n            return opt.axisValuesList;\n        case property_1.Property.AXIS_TITLE:\n            return opt.axisTitles;\n        case property_1.Property.AXIS_TITLECOLOR:\n            return opt.axisTitleColors;\n        case property_1.Property.AXIS_TITLEFONT:\n            return opt.axisTitleFonts;\n        case property_1.Property.AXIS_TITLEFONTWEIGHT:\n            return opt.axisTitleFontWeights;\n        case property_1.Property.AXIS_TITLEFONTSIZE:\n            return opt.axisTitleFontSizes;\n        case property_1.Property.AXIS_TITLEOFFSET:\n            return opt.axisTitleOffsets;\n        case property_1.Property.AXIS_TITLEMAXLENGTH:\n            return opt.axisTitleMaxLengths;\n        case property_1.Property.AXIS_CHARACTERWIDTH:\n            return opt.axisCharacterWidths;\n        case property_1.Property.BIN_MAXBINS:\n            return opt.maxBinsList;\n        case property_1.Property.CHANNEL:\n            return opt.channels;\n        case property_1.Property.MARK:\n            return opt.marks;\n        case property_1.Property.LEGEND_ORIENT:\n            return opt.legendOrients;\n        case property_1.Property.LEGEND_OFFSET:\n            return opt.legendOffsets;\n        case property_1.Property.LEGEND_VALUES:\n            return opt.legendValuesList;\n        case property_1.Property.LEGEND_FORMAT:\n            return opt.legendFormats;\n        case property_1.Property.LEGEND_LABELALIGN:\n            return opt.legendLabelAligns;\n        case property_1.Property.LEGEND_LABELBASELINE:\n            return opt.legendLabelBaselines;\n        case property_1.Property.LEGEND_LABELCOLOR:\n            return opt.legendLabelColors;\n        case property_1.Property.LEGEND_LABELFONT:\n            return opt.legendLabelFonts;\n        case property_1.Property.LEGEND_LABELFONTSIZE:\n            return opt.legendLabelFontSizes;\n        case property_1.Property.LEGEND_SYMBOLCOLOR:\n            return opt.legendSymbolColors;\n        case property_1.Property.LEGEND_SYMBOLSHAPE:\n            return opt.legendSymbolShapes;\n        case property_1.Property.LEGEND_SYMBOLSIZE:\n            return opt.legendSymbolSizes;\n        case property_1.Property.LEGEND_SYMBOLSTROKEWIDTH:\n            return opt.legendSymbolStrokeWidths;\n        case property_1.Property.LEGEND_TITLE:\n            return opt.legendTitles;\n        case property_1.Property.LEGEND_TITLECOLOR:\n            return opt.legendTitleColors;\n        case property_1.Property.LEGEND_TITLEFONT:\n            return opt.legendTitleFonts;\n        case property_1.Property.LEGEND_TITLEFONTSIZE:\n            return opt.legendTitleFontSizes;\n        case property_1.Property.LEGEND_TITLEFONTWEIGHT:\n            return opt.legendTitleFontWeights;\n        case property_1.Property.SORT:\n            return opt.sorts;\n        case property_1.Property.SORT_OP:\n            return opt.sortOps;\n        case property_1.Property.SORT_ORDER:\n            return opt.sortOrders;\n        case property_1.Property.SCALE_BANDSIZE:\n            return opt.scaleBandSizes;\n        case property_1.Property.SCALE_DOMAIN:\n            return opt.scaleDomains;\n        case property_1.Property.SCALE_EXPONENT:\n            return opt.scaleExponents;\n        case property_1.Property.SCALE_RANGE:\n            return opt.scaleRanges;\n        case property_1.Property.SCALE_TYPE:\n            return opt.scaleTypes;\n        case property_1.Property.TIMEUNIT:\n            return opt.timeUnits;\n        case property_1.Property.TYPE:\n            return opt.types;\n    }\n    /* istanbul ignore next */\n    throw new Error('No default enumValues for ' + prop);\n}\nexports.getDefaultEnumValues = getDefaultEnumValues;\n/**\n * Internal class for specQuery that provides helper for the enumeration process.\n */\nvar SpecQueryModel = (function () {\n    function SpecQueryModel(spec, enumSpecIndex, schema, opt, enumSpecAssignment) {\n        this._rankingScore = {};\n        this._spec = spec;\n        this._channelCount = spec.encodings.reduce(function (m, encQ) {\n            if (!enumspec_1.isEnumSpec(encQ.channel) && encQ.autoCount !== false) {\n                m[encQ.channel] = 1;\n            }\n            return m;\n        }, {});\n        this._enumSpecIndex = enumSpecIndex;\n        this._enumSpecAssignment = enumSpecAssignment;\n        this._opt = opt;\n        this._schema = schema;\n    }\n    /**\n     * Build an enumSpecIndex by detecting enumeration specifiers\n     * in the input specQuery and replace short enum specs with\n     * full ones that includes both names and enumValues.\n     *\n     * @return a SpecQueryModel that wraps the specQuery and the enumSpecIndex.\n     */\n    SpecQueryModel.build = function (specQ, schema, opt) {\n        var enumSpecIndex = new enumspecindex_1.EnumSpecIndex();\n        // mark\n        if (enumspec_1.isEnumSpec(specQ.mark)) {\n            var name_1 = getDefaultName(property_1.Property.MARK);\n            specQ.mark = enumspec_1.initEnumSpec(specQ.mark, name_1, opt.marks);\n            enumSpecIndex.setMark(specQ.mark);\n        }\n        // TODO: transform\n        // encodings\n        specQ.encodings.forEach(function (encQ, index) {\n            if (encQ.autoCount !== undefined) {\n                // This is only for testing purpose\n                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');\n                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative\n            }\n            if (encQ.type === undefined) {\n                // type is optional -- we automatically augment enum spec if not specified\n                encQ.type = enumspec_1.SHORT_ENUM_SPEC;\n            }\n            // For each property of the encodingQuery, enumerate\n            property_1.ENCODING_PROPERTIES.forEach(function (prop) {\n                if (enumspec_1.isEnumSpec(encQ[prop])) {\n                    // Assign default enum spec name and enum values.\n                    var defaultEnumSpecName = getDefaultName(prop) + index;\n                    var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\n                    var enumSpec = encQ[prop] = enumspec_1.initEnumSpec(encQ[prop], defaultEnumSpecName, defaultEnumValues);\n                    // Add index of the encoding mapping to the property's enum spec index.\n                    enumSpecIndex.setEncodingProperty(index, prop, enumSpec);\n                }\n            });\n            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)\n            property_1.NESTED_ENCODING_PROPERTIES.forEach(function (nestedProp) {\n                var propObj = encQ[nestedProp.parent]; // the property object e.g., encQ.bin\n                if (propObj) {\n                    var prop = nestedProp.property;\n                    var child = nestedProp.child;\n                    if (enumspec_1.isEnumSpec(propObj[child])) {\n                        // Assign default enum spec name and enum values.\n                        var defaultEnumSpecName = getDefaultName(prop) + index;\n                        var defaultEnumValues = getDefaultEnumValues(prop, schema, opt);\n                        var enumSpec = propObj[child] = enumspec_1.initEnumSpec(propObj[child], defaultEnumSpecName, defaultEnumValues);\n                        // Add index of the encoding mapping to the property's enum spec index.\n                        enumSpecIndex.setEncodingProperty(index, prop, enumSpec);\n                    }\n                }\n            });\n        });\n        // AUTO COUNT\n        // Add Auto Count Field\n        if (opt.autoAddCount) {\n            var countEncQ = {\n                channel: {\n                    name: getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,\n                    enum: getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)\n                },\n                autoCount: {\n                    name: getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,\n                    enum: [false, true]\n                },\n                type: type_1.Type.QUANTITATIVE\n            };\n            specQ.encodings.push(countEncQ);\n            var index = specQ.encodings.length - 1;\n            // Add index of the encoding mapping to the property's enum spec index.\n            enumSpecIndex.setEncodingProperty(index, property_1.Property.CHANNEL, countEncQ.channel);\n            enumSpecIndex.setEncodingProperty(index, property_1.Property.AUTOCOUNT, countEncQ.autoCount);\n        }\n        return new SpecQueryModel(specQ, enumSpecIndex, schema, opt, {});\n    };\n    Object.defineProperty(SpecQueryModel.prototype, \"enumSpecIndex\", {\n        get: function () {\n            return this._enumSpecIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"schema\", {\n        get: function () {\n            return this._schema;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"specQuery\", {\n        get: function () {\n            return this._spec;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SpecQueryModel.prototype.duplicate = function () {\n        return new SpecQueryModel(util_1.duplicate(this._spec), this._enumSpecIndex, this._schema, this._opt, util_1.duplicate(this._enumSpecAssignment));\n    };\n    SpecQueryModel.prototype.setMark = function (mark) {\n        var name = this._spec.mark.name;\n        this._enumSpecAssignment[name] = this._spec.mark = mark;\n    };\n    SpecQueryModel.prototype.resetMark = function () {\n        var enumSpec = this._spec.mark = this._enumSpecIndex.mark;\n        delete this._enumSpecAssignment[enumSpec.name];\n    };\n    SpecQueryModel.prototype.getMark = function () {\n        return this._spec.mark;\n    };\n    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (nestedProp) {\n            return encQ[nestedProp.parent][nestedProp.child];\n        }\n        return encQ[prop]; // encoding property (non-nested)\n    };\n    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, enumSpec) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (prop === property_1.Property.CHANNEL && encQ.channel && !enumspec_1.isEnumSpec(encQ.channel)) {\n            // If there is an old channel\n            this._channelCount[encQ.channel]--;\n        }\n        if (nestedProp) {\n            encQ[nestedProp.parent][nestedProp.child] = value;\n        }\n        else if (property_1.hasNestedProperty(prop) && value === true) {\n            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties\n            { enum: undefined, name: undefined } // except name and values to it no longer an enumSpec\n            );\n        }\n        else {\n            encQ[prop] = value;\n        }\n        this._enumSpecAssignment[enumSpec.name] = value;\n        if (prop === property_1.Property.CHANNEL) {\n            // If there is a new channel, make sure it exists and add it to the count.\n            this._channelCount[value] = (this._channelCount[value] || 0) + 1;\n        }\n    };\n    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, enumSpec) {\n        var encQ = this._spec.encodings[index];\n        var nestedProp = property_1.getNestedEncodingProperty(prop);\n        if (prop === property_1.Property.CHANNEL) {\n            this._channelCount[encQ.channel]--;\n        }\n        // reset it to enumSpec\n        if (nestedProp) {\n            encQ[nestedProp.parent][nestedProp.child] = enumSpec;\n        }\n        else {\n            encQ[prop] = enumSpec;\n        }\n        // add remove value that is reset from the assignment map\n        delete this._enumSpecAssignment[enumSpec.name];\n    };\n    SpecQueryModel.prototype.channelUsed = function (channel) {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._channelCount[channel] > 0;\n    };\n    SpecQueryModel.prototype.stack = function () {\n        return spec_1.stack(this._spec);\n    };\n    SpecQueryModel.prototype.getEncodings = function () {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._spec.encodings.filter(function (encQ) { return encQ.autoCount !== false; });\n    };\n    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {\n        for (var i = 0; i < this._spec.encodings.length; i++) {\n            if (this._spec.encodings[i].channel === channel) {\n                return this._spec.encodings[i];\n            }\n        }\n        return undefined;\n    };\n    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {\n        return this._spec.encodings[i];\n    };\n    SpecQueryModel.prototype.isDimension = function (channel) {\n        var encQ = this.getEncodingQueryByChannel(channel);\n        return encQ && encoding_1.isDimension(encQ);\n    };\n    SpecQueryModel.prototype.isMeasure = function (channel) {\n        var encQ = this.getEncodingQueryByChannel(channel);\n        return encQ && encoding_1.isMeasure(encQ);\n    };\n    SpecQueryModel.prototype.isAggregate = function () {\n        return spec_1.isAggregate(this._spec);\n    };\n    SpecQueryModel.prototype.toShorthand = function (groupBy) {\n        if (groupBy) {\n            var include = {}, replace = {};\n            groupby_1.parse(groupBy, include, replace);\n            return shorthand_1.spec(this._spec, include, shorthand_1.getReplacerIndex(replace));\n        }\n        return shorthand_1.spec(this._spec);\n    };\n    SpecQueryModel.prototype._encoding = function () {\n        var encoding = {};\n        for (var i = 0; i < this._spec.encodings.length; i++) {\n            var encQ = this._spec.encodings[i];\n            var fieldDef = {};\n            // For count field that is automatically added, convert to correct vega-lite fieldDef\n            if (encQ.autoCount === true) {\n                fieldDef.aggregate = aggregate_1.AggregateOp.COUNT;\n                fieldDef.field = '*';\n                fieldDef.type = type_1.Type.QUANTITATIVE;\n            }\n            else if (encQ.autoCount === false) {\n                continue; // Do not include this in the output.\n            }\n            // if channel is an enum spec, return null\n            if (enumspec_1.isEnumSpec(encQ.channel))\n                return null;\n            // assemble other property into a field def.\n            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND];\n            // TODO(#226):\n            // write toSpec() and toShorthand() in a way that prevents outputting inapplicable scale, sort, axis / legend\n            for (var j = 0; j < PROPERTIES.length; j++) {\n                var prop = PROPERTIES[j];\n                // if the property is an enum spec, return null\n                if (enumspec_1.isEnumSpec(encQ[prop]))\n                    return null;\n                // otherwise, assign the proper to the field def\n                if (encQ[prop] !== undefined) {\n                    if (!shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop] ||\n                        shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop][encQ.channel]) {\n                        fieldDef[prop] = encQ[prop];\n                    }\n                }\n            }\n            if (fieldDef.bin === false) {\n                // exclude bin false\n                delete fieldDef.bin;\n            }\n            encoding[encQ.channel] = fieldDef;\n        }\n        return encoding;\n    };\n    /**\n     * Convert a query to a Vega-Lite spec if it is completed.\n     * @return a Vega-Lite spec if completed, null otherwise.\n     */\n    SpecQueryModel.prototype.toSpec = function (data) {\n        if (enumspec_1.isEnumSpec(this._spec.mark))\n            return null;\n        var spec = {};\n        data = data || this._spec.data;\n        if (data) {\n            spec.data = data;\n        }\n        if (this._spec.transform) {\n            spec.transform = this._spec.transform;\n        }\n        spec.mark = this._spec.mark;\n        spec.encoding = this._encoding();\n        if (spec.encoding === null) {\n            return null;\n        }\n        if (this._spec.config || this._opt.defaultSpecConfig)\n            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);\n        return spec;\n    };\n    SpecQueryModel.prototype.getRankingScore = function (rankingName) {\n        return this._rankingScore[rankingName];\n    };\n    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {\n        this._rankingScore[rankingName] = score;\n    };\n    return SpecQueryModel;\n}());\nexports.SpecQueryModel = SpecQueryModel;\nvar SpecQueryModelGroup = (function () {\n    function SpecQueryModelGroup(name, path, items, groupBy, orderGroupBy) {\n        if (name === void 0) { name = ''; }\n        if (path === void 0) { path = ''; }\n        if (items === void 0) { items = []; }\n        if (groupBy === void 0) { groupBy = undefined; }\n        if (orderGroupBy === void 0) { orderGroupBy = undefined; }\n        this._name = name;\n        this._path = path;\n        this._items = items;\n        this._groupBy = groupBy;\n        this._orderGroupBy = orderGroupBy;\n    }\n    SpecQueryModelGroup.prototype.getTopSpecQueryModel = function () {\n        var topItem = this._items[0];\n        if (topItem instanceof SpecQueryModelGroup) {\n            return topItem.getTopSpecQueryModel();\n        }\n        else {\n            return topItem;\n        }\n    };\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"items\", {\n        get: function () {\n            return this._items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"groupBy\", {\n        get: function () {\n            return this._groupBy;\n        },\n        set: function (groupBy) {\n            this._groupBy = groupBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModelGroup.prototype, \"orderGroupBy\", {\n        get: function () {\n            return this._orderGroupBy;\n        },\n        set: function (orderGroupBy) {\n            this._orderGroupBy = orderGroupBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SpecQueryModelGroup;\n}());\nexports.SpecQueryModelGroup = SpecQueryModelGroup;\n//# sourceMappingURL=model.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar util_1 = require('datalib/src/util');\nvar enumspec_1 = require('./enumspec');\nvar model_1 = require('./model');\nvar util_2 = require('./util');\nvar groupby_1 = require('./query/groupby');\nvar shorthand_1 = require('./query/shorthand');\nvar spec_1 = require('./query/spec');\n/**\n * Registry for all possible grouping key functions.\n */\nvar groupRegistry = {};\n/**\n * Add a grouping function to the registry.\n */\nfunction registerKeyFn(name, keyFn) {\n    groupRegistry[name] = keyFn;\n}\nexports.registerKeyFn = registerKeyFn;\nexports.FIELD = 'field';\nexports.FIELD_TRANSFORM = 'fieldTransform';\nexports.ENCODING = 'encoding';\nexports.TRANSPOSE = 'transpose';\nexports.SPEC = 'spec';\n/**\n * Group the input spec query model by a key function registered in the group registry\n * @return\n */\nfunction nest(specModels, query) {\n    if (query.nest) {\n        var rootGroup_1 = new model_1.SpecQueryModelGroup();\n        var groupIndex_1 = {};\n        // global `includes` and `replaces` will get augmented by each level's groupBy.\n        // Upper level's `groupBy` will get cascaded to lower-level groupBy.\n        // `replace` can be overriden in a lower-level to support different grouping.\n        var includes_1 = [];\n        var replaces = [];\n        var replacers_1 = [];\n        for (var l = 0; l < query.nest.length; l++) {\n            includes_1.push(l > 0 ? util_2.duplicate(includes_1[l - 1]) : {});\n            replaces.push(l > 0 ? util_2.duplicate(replaces[l - 1]) : {});\n            var groupBy = query.nest[l].groupBy;\n            if (util_1.isArray(groupBy)) {\n                groupby_1.parse(groupBy, includes_1[l], replaces[l]);\n                replacers_1.push(shorthand_1.getReplacerIndex(replaces[l]));\n            }\n        }\n        // With includes and replacers, now we can construct the nesting tree\n        specModels.forEach(function (specM) {\n            var path = '';\n            var group = rootGroup_1;\n            for (var l = 0; l < query.nest.length; l++) {\n                var groupBy = group.groupBy = query.nest[l].groupBy;\n                group.orderGroupBy = query.nest[l].orderGroupBy;\n                var key = util_1.isArray(groupBy) ?\n                    shorthand_1.spec(specM.specQuery, includes_1[l], replacers_1[l]) :\n                    groupRegistry[groupBy](specM);\n                path += '/' + key;\n                if (!groupIndex_1[path]) {\n                    groupIndex_1[path] = new model_1.SpecQueryModelGroup(key, path, []);\n                    group.items.push(groupIndex_1[path]);\n                }\n                group = groupIndex_1[path];\n            }\n            group.items.push(specM);\n        });\n        return rootGroup_1;\n    }\n    else {\n        // no nesting, just return a flat group\n        return new model_1.SpecQueryModelGroup('', '', specModels);\n    }\n}\nexports.nest = nest;\nregisterKeyFn(exports.FIELD, function (specM) {\n    return specM.getEncodings().map(function (encQ) { return encQ.field; })\n        .filter(function (field) { return field && field !== '*'; })\n        .sort()\n        .join('|');\n});\nregisterKeyFn(exports.FIELD_TRANSFORM, function (specM) {\n    return specM.getEncodings().map(function (encQ) { return shorthand_1.fieldDef(encQ); })\n        .sort()\n        .join('|');\n});\nfunction channelType(channel) {\n    if (enumspec_1.isEnumSpec(channel)) {\n        return enumspec_1.SHORT_ENUM_SPEC + '';\n    }\n    var c = channel;\n    switch (c) {\n        case channel_1.Channel.X:\n        case channel_1.Channel.Y:\n            return 'xy';\n        case channel_1.Channel.ROW:\n        case channel_1.Channel.COLUMN:\n            return 'facet';\n        case channel_1.Channel.COLOR:\n        case channel_1.Channel.SIZE:\n        case channel_1.Channel.SHAPE:\n        case channel_1.Channel.OPACITY:\n            return 'non-xy';\n        case channel_1.Channel.TEXT:\n        case channel_1.Channel.DETAIL:\n        case channel_1.Channel.PATH:\n        case channel_1.Channel.ORDER:\n            return c + '';\n        /* istanbul ignore next */\n        default:\n            console.warn('channel type not implemented for ' + c);\n            return c + '';\n    }\n}\nfunction stringifyStack(specM) {\n    var _stack = spec_1.stack(specM.specQuery);\n    return (!!_stack ? 'stack=' + _stack.offset + '|' : '');\n}\nregisterKeyFn(exports.ENCODING, function (specM) {\n    // mark does not matter\n    return stringifyStack(specM) +\n        specM.getEncodings().map(function (encQ) {\n            var fieldDef = shorthand_1.fieldDef(encQ);\n            return channelType(encQ.channel) + ':' + fieldDef;\n        })\n            .sort()\n            .join('|');\n});\nregisterKeyFn(exports.TRANSPOSE, function (specM) {\n    return specM.getMark() + '|' +\n        stringifyStack(specM) +\n        specM.getEncodings().map(function (encQ) {\n            var fieldDef = shorthand_1.fieldDef(encQ);\n            var channel = (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) ? 'xy' :\n                (encQ.channel === channel_1.Channel.ROW || encQ.channel === channel_1.Channel.COLUMN) ? 'facet' :\n                    encQ.channel;\n            return channel + ':' + fieldDef;\n        })\n            .sort()\n            .join('|');\n});\nregisterKeyFn(exports.SPEC, function (specM) { return JSON.stringify(specM.specQuery); });\n//# sourceMappingURL=nest.js.map",
    "\"use strict\";\nvar scale_1 = require('vega-lite/src/scale');\n(function (Property) {\n    Property[Property[\"MARK\"] = 'mark'] = \"MARK\";\n    Property[Property[\"FILTER\"] = 'filter'] = \"FILTER\";\n    // TODO: Sub-properties for filter\n    Property[Property[\"CALCULATE\"] = 'calculate'] = \"CALCULATE\";\n    // TODO: Sub-properties for calculate\n    Property[Property[\"FILTERINVALID\"] = 'filterInvalid'] = \"FILTERINVALID\";\n    // Layout\n    Property[Property[\"STACK\"] = 'stack'] = \"STACK\";\n    // TODO: sub parts of stack\n    // Encoding Properties\n    Property[Property[\"CHANNEL\"] = 'channel'] = \"CHANNEL\";\n    Property[Property[\"AGGREGATE\"] = 'aggregate'] = \"AGGREGATE\";\n    Property[Property[\"AUTOCOUNT\"] = 'autoCount'] = \"AUTOCOUNT\";\n    Property[Property[\"BIN\"] = 'bin'] = \"BIN\";\n    Property[Property[\"BIN_MAXBINS\"] = 'binMaxBins'] = \"BIN_MAXBINS\";\n    Property[Property[\"HAS_FN\"] = 'hasFn'] = \"HAS_FN\";\n    Property[Property[\"TIMEUNIT\"] = 'timeUnit'] = \"TIMEUNIT\";\n    Property[Property[\"FIELD\"] = 'field'] = \"FIELD\";\n    Property[Property[\"TYPE\"] = 'type'] = \"TYPE\";\n    // - Sort\n    Property[Property[\"SORT\"] = 'sort'] = \"SORT\";\n    Property[Property[\"SORT_FIELD\"] = 'sortField'] = \"SORT_FIELD\";\n    Property[Property[\"SORT_OP\"] = 'sortOp'] = \"SORT_OP\";\n    Property[Property[\"SORT_ORDER\"] = 'sortOrder'] = \"SORT_ORDER\";\n    // - Scale\n    Property[Property[\"SCALE\"] = 'scale'] = \"SCALE\";\n    Property[Property[\"SCALE_BANDSIZE\"] = 'scaleBandSize'] = \"SCALE_BANDSIZE\";\n    Property[Property[\"SCALE_CLAMP\"] = 'scaleClamp'] = \"SCALE_CLAMP\";\n    Property[Property[\"SCALE_DOMAIN\"] = 'scaleDomain'] = \"SCALE_DOMAIN\";\n    Property[Property[\"SCALE_EXPONENT\"] = 'scaleExponent'] = \"SCALE_EXPONENT\";\n    Property[Property[\"SCALE_NICE\"] = 'scaleNice'] = \"SCALE_NICE\";\n    Property[Property[\"SCALE_RANGE\"] = 'scaleRange'] = \"SCALE_RANGE\";\n    Property[Property[\"SCALE_ROUND\"] = 'scaleRound'] = \"SCALE_ROUND\";\n    Property[Property[\"SCALE_TYPE\"] = 'scaleType'] = \"SCALE_TYPE\";\n    Property[Property[\"SCALE_USERAWDOMAIN\"] = 'scaleUseRawDomain'] = \"SCALE_USERAWDOMAIN\";\n    Property[Property[\"SCALE_ZERO\"] = 'scaleZero'] = \"SCALE_ZERO\";\n    // - Axis\n    Property[Property[\"AXIS\"] = 'axis'] = \"AXIS\";\n    // General Axis Properties\n    Property[Property[\"AXIS_AXISCOLOR\"] = 'axisAxisColor'] = \"AXIS_AXISCOLOR\";\n    Property[Property[\"AXIS_AXISWIDTH\"] = 'axisAxisWidth'] = \"AXIS_AXISWIDTH\";\n    Property[Property[\"AXIS_LAYER\"] = 'axisLayer'] = \"AXIS_LAYER\";\n    Property[Property[\"AXIS_OFFSET\"] = 'axisOffset'] = \"AXIS_OFFSET\";\n    Property[Property[\"AXIS_ORIENT\"] = 'axisOrient'] = \"AXIS_ORIENT\";\n    // Axis_Grid Properties\n    Property[Property[\"AXIS_GRID\"] = 'axisGrid'] = \"AXIS_GRID\";\n    Property[Property[\"AXIS_GRIDCOLOR\"] = 'axisGridColor'] = \"AXIS_GRIDCOLOR\";\n    Property[Property[\"AXIS_GRIDDASH\"] = 'axisGridDash'] = \"AXIS_GRIDDASH\";\n    Property[Property[\"AXIS_GRIDOPACITY\"] = 'axisGridOpacity'] = \"AXIS_GRIDOPACITY\";\n    Property[Property[\"AXIS_GRIDWIDTH\"] = 'axisGridWidth'] = \"AXIS_GRIDWIDTH\";\n    // Axis Properties\n    Property[Property[\"AXIS_LABELS\"] = 'axisLabels'] = \"AXIS_LABELS\";\n    Property[Property[\"AXIS_FORMAT\"] = 'axisFormat'] = \"AXIS_FORMAT\";\n    Property[Property[\"AXIS_LABELANGLE\"] = 'axisLabelAngle'] = \"AXIS_LABELANGLE\";\n    Property[Property[\"AXIS_LABELMAXLENGTH\"] = 'axisLabelMaxLength'] = \"AXIS_LABELMAXLENGTH\";\n    Property[Property[\"AXIS_SHORTTIMELABELS\"] = 'axisShortTimeLabels'] = \"AXIS_SHORTTIMELABELS\";\n    // Axis_Tick Properties\n    Property[Property[\"AXIS_SUBDIVIDE\"] = 'axisSubdivide'] = \"AXIS_SUBDIVIDE\";\n    Property[Property[\"AXIS_TICKS\"] = 'axisTicks'] = \"AXIS_TICKS\";\n    Property[Property[\"AXIS_TICKCOLOR\"] = 'axisTickColor'] = \"AXIS_TICKCOLOR\";\n    Property[Property[\"AXIS_TICKLABELCOLOR\"] = 'axisTickLabelColor'] = \"AXIS_TICKLABELCOLOR\";\n    Property[Property[\"AXIS_TICKLABELFONT\"] = 'axisTickLabelFont'] = \"AXIS_TICKLABELFONT\";\n    Property[Property[\"AXIS_TICKLABELFONTSIZE\"] = 'axisTickLabelFontSize'] = \"AXIS_TICKLABELFONTSIZE\";\n    Property[Property[\"AXIS_TICKPADDING\"] = 'axisTickPadding'] = \"AXIS_TICKPADDING\";\n    Property[Property[\"AXIS_TICKSIZE\"] = 'axisTickSize'] = \"AXIS_TICKSIZE\";\n    Property[Property[\"AXIS_TICKSIZEMAJOR\"] = 'axisTickSizeMajor'] = \"AXIS_TICKSIZEMAJOR\";\n    Property[Property[\"AXIS_TICKSIZEMINOR\"] = 'axisTickSizeMinor'] = \"AXIS_TICKSIZEMINOR\";\n    Property[Property[\"AXIS_TICKSIZEEND\"] = 'axisTickSizeEnd'] = \"AXIS_TICKSIZEEND\";\n    Property[Property[\"AXIS_TICKWIDTH\"] = 'axisTickWidth'] = \"AXIS_TICKWIDTH\";\n    Property[Property[\"AXIS_VALUES\"] = 'axisValues'] = \"AXIS_VALUES\";\n    // Axis_Title Properties\n    Property[Property[\"AXIS_TITLE\"] = 'axisTitle'] = \"AXIS_TITLE\";\n    Property[Property[\"AXIS_TITLECOLOR\"] = 'axisTitleColor'] = \"AXIS_TITLECOLOR\";\n    Property[Property[\"AXIS_TITLEFONT\"] = 'axisTitleFont'] = \"AXIS_TITLEFONT\";\n    Property[Property[\"AXIS_TITLEFONTSIZE\"] = 'axisTitleFontSize'] = \"AXIS_TITLEFONTSIZE\";\n    Property[Property[\"AXIS_TITLEFONTWEIGHT\"] = 'axisTitleFontWeight'] = \"AXIS_TITLEFONTWEIGHT\";\n    Property[Property[\"AXIS_TITLEOFFSET\"] = 'axisTitleOffset'] = \"AXIS_TITLEOFFSET\";\n    Property[Property[\"AXIS_TITLEMAXLENGTH\"] = 'axisTitleMaxLength'] = \"AXIS_TITLEMAXLENGTH\";\n    Property[Property[\"AXIS_CHARACTERWIDTH\"] = 'axisCharacterWidth'] = \"AXIS_CHARACTERWIDTH\";\n    // - Legend\n    Property[Property[\"LEGEND\"] = 'legend'] = \"LEGEND\";\n    // General Legend Properties\n    Property[Property[\"LEGEND_ORIENT\"] = 'legendOrient'] = \"LEGEND_ORIENT\";\n    Property[Property[\"LEGEND_OFFSET\"] = 'legendOffset'] = \"LEGEND_OFFSET\";\n    Property[Property[\"LEGEND_VALUES\"] = 'legendValues'] = \"LEGEND_VALUES\";\n    // Legend_Label Properties\n    Property[Property[\"LEGEND_FORMAT\"] = 'legendFormat'] = \"LEGEND_FORMAT\";\n    Property[Property[\"LEGEND_LABELALIGN\"] = 'legendLabelAlign'] = \"LEGEND_LABELALIGN\";\n    Property[Property[\"LEGEND_LABELBASELINE\"] = 'legendLabelBaseline'] = \"LEGEND_LABELBASELINE\";\n    Property[Property[\"LEGEND_LABELCOLOR\"] = 'legendLabelColor'] = \"LEGEND_LABELCOLOR\";\n    Property[Property[\"LEGEND_LABELFONT\"] = 'legendLabelFont'] = \"LEGEND_LABELFONT\";\n    Property[Property[\"LEGEND_LABELFONTSIZE\"] = 'legendLabelFontSize'] = \"LEGEND_LABELFONTSIZE\";\n    Property[Property[\"LEGEND_SHORTTIMELABELS\"] = 'legendShortTimeLabels'] = \"LEGEND_SHORTTIMELABELS\";\n    // Legend_Symbol Properties\n    Property[Property[\"LEGEND_SYMBOLCOLOR\"] = 'legendSymbolColor'] = \"LEGEND_SYMBOLCOLOR\";\n    Property[Property[\"LEGEND_SYMBOLSHAPE\"] = 'legendSymbolShape'] = \"LEGEND_SYMBOLSHAPE\";\n    Property[Property[\"LEGEND_SYMBOLSIZE\"] = 'legendSymbolSize'] = \"LEGEND_SYMBOLSIZE\";\n    Property[Property[\"LEGEND_SYMBOLSTROKEWIDTH\"] = 'legendSymbolStrokeWidth'] = \"LEGEND_SYMBOLSTROKEWIDTH\";\n    // Legend_Title Properties\n    Property[Property[\"LEGEND_TITLE\"] = 'legendTitle'] = \"LEGEND_TITLE\";\n    Property[Property[\"LEGEND_TITLECOLOR\"] = 'legendTitleColor'] = \"LEGEND_TITLECOLOR\";\n    Property[Property[\"LEGEND_TITLEFONT\"] = 'legendTitleFont'] = \"LEGEND_TITLEFONT\";\n    Property[Property[\"LEGEND_TITLEFONTSIZE\"] = 'legendTitleFontSize'] = \"LEGEND_TITLEFONTSIZE\";\n    Property[Property[\"LEGEND_TITLEFONTWEIGHT\"] = 'legendTitleFontWeight'] = \"LEGEND_TITLEFONTWEIGHT\";\n})(exports.Property || (exports.Property = {}));\nvar Property = exports.Property;\nfunction hasNestedProperty(prop) {\n    switch (prop) {\n        case Property.BIN:\n        case Property.SCALE:\n        case Property.SORT:\n        case Property.AXIS:\n        case Property.LEGEND:\n            return true;\n        case Property.MARK:\n        case Property.FILTER:\n        case Property.CALCULATE:\n        case Property.FILTERINVALID:\n        case Property.STACK:\n        case Property.CHANNEL:\n        case Property.AGGREGATE:\n        case Property.AUTOCOUNT:\n        case Property.TIMEUNIT:\n        case Property.FIELD:\n        case Property.TYPE:\n        case Property.BIN_MAXBINS:\n        case Property.SCALE_BANDSIZE:\n        case Property.SCALE_CLAMP:\n        case Property.SCALE_DOMAIN:\n        case Property.SCALE_EXPONENT:\n        case Property.SCALE_NICE:\n        case Property.SCALE_RANGE:\n        case Property.SCALE_ROUND:\n        case Property.SCALE_TYPE:\n        case Property.SCALE_USERAWDOMAIN:\n        case Property.SCALE_ZERO:\n        case Property.AXIS_AXISCOLOR:\n        case Property.AXIS_AXISWIDTH:\n        case Property.AXIS_LAYER:\n        case Property.AXIS_OFFSET:\n        case Property.AXIS_ORIENT:\n        case Property.AXIS_GRID:\n        case Property.AXIS_GRIDCOLOR:\n        case Property.AXIS_GRIDDASH:\n        case Property.AXIS_GRIDOPACITY:\n        case Property.AXIS_GRIDWIDTH:\n        case Property.AXIS_LABELS:\n        case Property.AXIS_FORMAT:\n        case Property.AXIS_LABELANGLE:\n        case Property.AXIS_LABELMAXLENGTH:\n        case Property.AXIS_SHORTTIMELABELS:\n        case Property.AXIS_TICKS:\n        case Property.AXIS_SUBDIVIDE:\n        case Property.AXIS_TICKCOLOR:\n        case Property.AXIS_TICKLABELCOLOR:\n        case Property.AXIS_TICKLABELFONT:\n        case Property.AXIS_TICKLABELFONTSIZE:\n        case Property.AXIS_TICKPADDING:\n        case Property.AXIS_TICKSIZE:\n        case Property.AXIS_TICKSIZEMAJOR:\n        case Property.AXIS_TICKSIZEMINOR:\n        case Property.AXIS_TICKSIZEEND:\n        case Property.AXIS_TICKWIDTH:\n        case Property.AXIS_VALUES:\n        case Property.AXIS_TITLE:\n        case Property.AXIS_TITLECOLOR:\n        case Property.AXIS_TITLEFONT:\n        case Property.AXIS_TITLEFONTSIZE:\n        case Property.AXIS_TITLEFONTWEIGHT:\n        case Property.AXIS_CHARACTERWIDTH:\n        case Property.AXIS_TITLEMAXLENGTH:\n        case Property.AXIS_TITLEOFFSET:\n        case Property.LEGEND_ORIENT:\n        case Property.LEGEND_OFFSET:\n        case Property.LEGEND_VALUES:\n        case Property.LEGEND_FORMAT:\n        case Property.LEGEND_LABELALIGN:\n        case Property.LEGEND_LABELBASELINE:\n        case Property.LEGEND_LABELCOLOR:\n        case Property.LEGEND_LABELFONT:\n        case Property.LEGEND_LABELFONTSIZE:\n        case Property.LEGEND_SHORTTIMELABELS:\n        case Property.LEGEND_SYMBOLCOLOR:\n        case Property.LEGEND_SYMBOLSHAPE:\n        case Property.LEGEND_SYMBOLSIZE:\n        case Property.LEGEND_SYMBOLSTROKEWIDTH:\n        case Property.LEGEND_TITLE:\n        case Property.LEGEND_TITLECOLOR:\n        case Property.LEGEND_TITLEFONT:\n        case Property.LEGEND_TITLEFONTSIZE:\n        case Property.LEGEND_TITLEFONTWEIGHT:\n            return false;\n    }\n    /* istanbul ignore next */\n    throw new Error('hasNestedProperty undefined for property ' + prop);\n}\nexports.hasNestedProperty = hasNestedProperty;\nexports.ENCODING_PROPERTIES = [\n    Property.CHANNEL,\n    Property.BIN,\n    Property.BIN_MAXBINS,\n    Property.TIMEUNIT,\n    Property.AGGREGATE,\n    Property.AUTOCOUNT,\n    Property.FIELD,\n    Property.TYPE,\n    Property.SORT,\n    Property.SORT_FIELD,\n    Property.SORT_OP,\n    Property.SORT_ORDER,\n    Property.SCALE,\n    Property.SCALE_BANDSIZE,\n    Property.SCALE_CLAMP,\n    Property.SCALE_DOMAIN,\n    Property.SCALE_EXPONENT,\n    Property.SCALE_NICE,\n    Property.SCALE_RANGE,\n    Property.SCALE_ROUND,\n    Property.SCALE_TYPE,\n    Property.SCALE_USERAWDOMAIN,\n    Property.SCALE_ZERO,\n    Property.AXIS,\n    Property.AXIS_AXISCOLOR,\n    Property.AXIS_AXISWIDTH,\n    Property.AXIS_CHARACTERWIDTH,\n    Property.AXIS_FORMAT,\n    Property.AXIS_GRID,\n    Property.AXIS_GRIDCOLOR,\n    Property.AXIS_GRIDDASH,\n    Property.AXIS_GRIDOPACITY,\n    Property.AXIS_GRIDWIDTH,\n    Property.AXIS_LABELANGLE,\n    Property.AXIS_LABELMAXLENGTH,\n    Property.AXIS_LABELS,\n    Property.AXIS_LAYER,\n    Property.AXIS_OFFSET,\n    Property.AXIS_ORIENT,\n    Property.AXIS_SHORTTIMELABELS,\n    Property.AXIS_SUBDIVIDE,\n    Property.AXIS_TICKCOLOR,\n    Property.AXIS_TICKLABELCOLOR,\n    Property.AXIS_TICKLABELFONT,\n    Property.AXIS_TICKLABELFONTSIZE,\n    Property.AXIS_TICKPADDING,\n    Property.AXIS_TICKS,\n    Property.AXIS_TICKSIZE,\n    Property.AXIS_TICKSIZEEND,\n    Property.AXIS_TICKSIZEMAJOR,\n    Property.AXIS_TICKSIZEMINOR,\n    Property.AXIS_TICKWIDTH,\n    Property.AXIS_TITLE,\n    Property.AXIS_TITLECOLOR,\n    Property.AXIS_TITLEFONT,\n    Property.AXIS_TITLEFONTSIZE,\n    Property.AXIS_TITLEFONTWEIGHT,\n    Property.AXIS_TITLEMAXLENGTH,\n    Property.AXIS_TITLEOFFSET,\n    Property.AXIS_VALUES,\n    Property.LEGEND,\n    Property.LEGEND_ORIENT,\n    Property.LEGEND_OFFSET,\n    Property.LEGEND_VALUES,\n    Property.LEGEND_FORMAT,\n    Property.LEGEND_LABELALIGN,\n    Property.LEGEND_LABELBASELINE,\n    Property.LEGEND_LABELCOLOR,\n    Property.LEGEND_LABELFONT,\n    Property.LEGEND_LABELFONTSIZE,\n    Property.LEGEND_SHORTTIMELABELS,\n    Property.LEGEND_SYMBOLCOLOR,\n    Property.LEGEND_SYMBOLSHAPE,\n    Property.LEGEND_SYMBOLSIZE,\n    Property.LEGEND_SYMBOLSTROKEWIDTH,\n    Property.LEGEND_TITLE,\n    Property.LEGEND_TITLECOLOR,\n    Property.LEGEND_TITLEFONT,\n    Property.LEGEND_TITLEFONTSIZE,\n    Property.LEGEND_TITLEFONTWEIGHT\n];\nexports.DEFAULT_PROPERTY_PRECEDENCE = [\n    // Projection\n    Property.TYPE,\n    Property.FIELD,\n    // TODO: Add stack and remove it from INCLUDE_ALL in shorthand\n    // TODO: Add filter and remove it from INCLUDE_ALL in shorthand\n    // TODO: Add calculate and remove it from INCLUDE_ALL in shorthand\n    // TODO: Add filterInvalid and remove it from INCLUDE_ALL in shorthand\n    // Field Transform\n    Property.BIN,\n    Property.TIMEUNIT,\n    Property.AGGREGATE,\n    Property.AUTOCOUNT,\n    Property.SORT,\n    Property.SORT_FIELD,\n    Property.SORT_OP,\n    Property.SORT_ORDER,\n    // Nested Transform Property\n    Property.BIN_MAXBINS,\n    // Encoding\n    Property.CHANNEL,\n    Property.MARK,\n    Property.SCALE,\n    Property.AXIS,\n    Property.LEGEND,\n    // Nested Encoding Property\n    // - Scale\n    Property.SCALE_BANDSIZE,\n    Property.SCALE_CLAMP,\n    Property.SCALE_DOMAIN,\n    Property.SCALE_EXPONENT,\n    Property.SCALE_NICE,\n    Property.SCALE_RANGE,\n    Property.SCALE_ROUND,\n    Property.SCALE_TYPE,\n    Property.SCALE_USERAWDOMAIN,\n    Property.SCALE_ZERO,\n    // - Axis\n    Property.AXIS_AXISCOLOR,\n    Property.AXIS_AXISWIDTH,\n    Property.AXIS_CHARACTERWIDTH,\n    Property.AXIS_FORMAT,\n    Property.AXIS_GRID,\n    Property.AXIS_GRIDCOLOR,\n    Property.AXIS_GRIDDASH,\n    Property.AXIS_GRIDOPACITY,\n    Property.AXIS_GRIDWIDTH,\n    Property.AXIS_LABELANGLE,\n    Property.AXIS_LABELMAXLENGTH,\n    Property.AXIS_LABELS,\n    Property.AXIS_LAYER,\n    Property.AXIS_OFFSET,\n    Property.AXIS_ORIENT,\n    Property.AXIS_SHORTTIMELABELS,\n    Property.AXIS_SUBDIVIDE,\n    Property.AXIS_TICKCOLOR,\n    Property.AXIS_TICKLABELCOLOR,\n    Property.AXIS_TICKLABELFONT,\n    Property.AXIS_TICKLABELFONTSIZE,\n    Property.AXIS_TICKPADDING,\n    Property.AXIS_TICKS,\n    Property.AXIS_TICKSIZE,\n    Property.AXIS_TICKSIZEEND,\n    Property.AXIS_TICKSIZEMAJOR,\n    Property.AXIS_TICKSIZEMINOR,\n    Property.AXIS_TICKWIDTH,\n    Property.AXIS_TITLE,\n    Property.AXIS_TITLECOLOR,\n    Property.AXIS_TITLEFONT,\n    Property.AXIS_TITLEFONTSIZE,\n    Property.AXIS_TITLEFONTWEIGHT,\n    Property.AXIS_TITLEMAXLENGTH,\n    Property.AXIS_TITLEOFFSET,\n    Property.AXIS_VALUES,\n    // - Legend\n    Property.LEGEND_ORIENT,\n    Property.LEGEND_OFFSET,\n    Property.LEGEND_VALUES,\n    Property.LEGEND_FORMAT,\n    Property.LEGEND_LABELALIGN,\n    Property.LEGEND_LABELBASELINE,\n    Property.LEGEND_LABELCOLOR,\n    Property.LEGEND_LABELFONT,\n    Property.LEGEND_LABELFONTSIZE,\n    Property.LEGEND_SHORTTIMELABELS,\n    Property.LEGEND_SYMBOLCOLOR,\n    Property.LEGEND_SYMBOLSHAPE,\n    Property.LEGEND_SYMBOLSIZE,\n    Property.LEGEND_SYMBOLSTROKEWIDTH,\n    Property.LEGEND_TITLE,\n    Property.LEGEND_TITLECOLOR,\n    Property.LEGEND_TITLEFONT,\n    Property.LEGEND_TITLEFONTSIZE,\n    Property.LEGEND_TITLEFONTWEIGHT\n];\nexports.NESTED_ENCODING_PROPERTIES = [\n    {\n        property: Property.BIN_MAXBINS,\n        parent: 'bin',\n        child: 'maxbins'\n    },\n    {\n        property: Property.SORT_FIELD,\n        parent: 'sort',\n        child: 'field'\n    },\n    {\n        property: Property.SORT_OP,\n        parent: 'sort',\n        child: 'op'\n    },\n    {\n        property: Property.SORT_ORDER,\n        parent: 'sort',\n        child: 'order'\n    },\n    {\n        property: Property.SCALE_BANDSIZE,\n        parent: 'scale',\n        child: 'bandSize'\n    },\n    {\n        property: Property.SCALE_CLAMP,\n        parent: 'scale',\n        child: 'clamp'\n    },\n    {\n        property: Property.SCALE_DOMAIN,\n        parent: 'scale',\n        child: 'domain'\n    },\n    {\n        property: Property.SCALE_EXPONENT,\n        parent: 'scale',\n        child: 'exponent'\n    },\n    {\n        property: Property.SCALE_NICE,\n        parent: 'scale',\n        child: 'nice'\n    },\n    {\n        property: Property.SCALE_RANGE,\n        parent: 'scale',\n        child: 'range'\n    },\n    {\n        property: Property.SCALE_ROUND,\n        parent: 'scale',\n        child: 'round'\n    },\n    {\n        property: Property.SCALE_TYPE,\n        parent: 'scale',\n        child: 'type'\n    },\n    {\n        property: Property.SCALE_USERAWDOMAIN,\n        parent: 'scale',\n        child: 'useRawDomain'\n    },\n    {\n        property: Property.SCALE_ZERO,\n        parent: 'scale',\n        child: 'zero'\n    },\n    {\n        property: Property.AXIS_AXISCOLOR,\n        parent: 'axis',\n        child: 'axisColor'\n    },\n    {\n        property: Property.AXIS_AXISWIDTH,\n        parent: 'axis',\n        child: 'axisWidth'\n    },\n    {\n        property: Property.AXIS_LAYER,\n        parent: 'axis',\n        child: 'layer'\n    },\n    {\n        property: Property.AXIS_OFFSET,\n        parent: 'axis',\n        child: 'offset'\n    },\n    {\n        property: Property.AXIS_ORIENT,\n        parent: 'axis',\n        child: 'orient'\n    },\n    {\n        property: Property.AXIS_GRID,\n        parent: 'axis',\n        child: 'grid'\n    },\n    {\n        property: Property.AXIS_GRIDCOLOR,\n        parent: 'axis',\n        child: 'gridColor'\n    },\n    {\n        property: Property.AXIS_GRIDDASH,\n        parent: 'axis',\n        child: 'gridDash'\n    },\n    {\n        property: Property.AXIS_GRIDOPACITY,\n        parent: 'axis',\n        child: 'gridOpacity'\n    },\n    {\n        property: Property.AXIS_GRIDWIDTH,\n        parent: 'axis',\n        child: 'gridWidth'\n    },\n    {\n        property: Property.AXIS_LABELS,\n        parent: 'axis',\n        child: 'labels'\n    },\n    {\n        property: Property.AXIS_FORMAT,\n        parent: 'axis',\n        child: 'format'\n    },\n    {\n        property: Property.AXIS_LABELANGLE,\n        parent: 'axis',\n        child: 'labelAngle'\n    },\n    {\n        property: Property.AXIS_LABELMAXLENGTH,\n        parent: 'axis',\n        child: 'labelMaxLength'\n    },\n    {\n        property: Property.AXIS_SHORTTIMELABELS,\n        parent: 'axis',\n        child: 'shortTimeLabels'\n    },\n    {\n        property: Property.AXIS_TICKS,\n        parent: 'axis',\n        child: 'ticks'\n    },\n    {\n        property: Property.AXIS_SUBDIVIDE,\n        parent: 'axis',\n        child: 'subdivide'\n    },\n    {\n        property: Property.AXIS_TICKCOLOR,\n        parent: 'axis',\n        child: 'tickColor'\n    },\n    {\n        property: Property.AXIS_TICKLABELCOLOR,\n        parent: 'axis',\n        child: 'tickLabelColor'\n    },\n    {\n        property: Property.AXIS_TICKLABELFONT,\n        parent: 'axis',\n        child: 'tickLabelFont'\n    },\n    {\n        property: Property.AXIS_TICKLABELFONTSIZE,\n        parent: 'axis',\n        child: 'tickLabelFontSize'\n    },\n    {\n        property: Property.AXIS_TICKPADDING,\n        parent: 'axis',\n        child: 'tickPadding'\n    },\n    {\n        property: Property.AXIS_TICKSIZE,\n        parent: 'axis',\n        child: 'tickSize'\n    },\n    {\n        property: Property.AXIS_TICKSIZEMAJOR,\n        parent: 'axis',\n        child: 'tickSizeMajor'\n    },\n    {\n        property: Property.AXIS_TICKSIZEMINOR,\n        parent: 'axis',\n        child: 'tickSizeMinor'\n    },\n    {\n        property: Property.AXIS_TICKSIZEEND,\n        parent: 'axis',\n        child: 'tickSizeEnd'\n    },\n    {\n        property: Property.AXIS_TICKWIDTH,\n        parent: 'axis',\n        child: 'tickWidth'\n    },\n    {\n        property: Property.AXIS_VALUES,\n        parent: 'axis',\n        child: 'values'\n    },\n    {\n        property: Property.AXIS_TITLE,\n        parent: 'axis',\n        child: 'title'\n    },\n    {\n        property: Property.AXIS_TITLECOLOR,\n        parent: 'axis',\n        child: 'titleColor'\n    },\n    {\n        property: Property.AXIS_TITLEFONT,\n        parent: 'axis',\n        child: 'titleFont'\n    },\n    {\n        property: Property.AXIS_TITLEFONTSIZE,\n        parent: 'axis',\n        child: 'titleFontSize'\n    },\n    {\n        property: Property.AXIS_TITLEFONTWEIGHT,\n        parent: 'axis',\n        child: 'titleFontWeight'\n    },\n    {\n        property: Property.AXIS_CHARACTERWIDTH,\n        parent: 'axis',\n        child: 'characterWidth'\n    },\n    {\n        property: Property.AXIS_TITLEMAXLENGTH,\n        parent: 'axis',\n        child: 'titleMaxLength'\n    },\n    {\n        property: Property.AXIS_TITLEOFFSET,\n        parent: 'axis',\n        child: 'titleOffset'\n    },\n    {\n        property: Property.LEGEND_ORIENT,\n        parent: 'legend',\n        child: 'orient'\n    },\n    {\n        property: Property.LEGEND_OFFSET,\n        parent: 'legend',\n        child: 'offset',\n    },\n    {\n        property: Property.LEGEND_VALUES,\n        parent: 'legend',\n        child: 'values'\n    },\n    {\n        property: Property.LEGEND_FORMAT,\n        parent: 'legend',\n        child: 'format'\n    },\n    {\n        property: Property.LEGEND_LABELALIGN,\n        parent: 'legend',\n        child: 'labelAlign'\n    },\n    {\n        property: Property.LEGEND_LABELBASELINE,\n        parent: 'legend',\n        child: 'labelBaseline'\n    },\n    {\n        property: Property.LEGEND_LABELFONT,\n        parent: 'legend',\n        child: 'labelFont'\n    },\n    {\n        property: Property.LEGEND_LABELFONTSIZE,\n        parent: 'legend',\n        child: 'labelFontSize'\n    },\n    {\n        property: Property.LEGEND_SHORTTIMELABELS,\n        parent: 'legend',\n        child: 'shortTimeLabels'\n    },\n    {\n        property: Property.LEGEND_SYMBOLCOLOR,\n        parent: 'legend',\n        child: 'symbolColor'\n    },\n    {\n        property: Property.LEGEND_SYMBOLSHAPE,\n        parent: 'legend',\n        child: 'symbolShape'\n    },\n    {\n        property: Property.LEGEND_SYMBOLSIZE,\n        parent: 'legend',\n        child: 'symbolSize'\n    },\n    {\n        property: Property.LEGEND_SYMBOLSTROKEWIDTH,\n        parent: 'legend',\n        child: 'symbolStrokeWidth'\n    },\n    {\n        property: Property.LEGEND_TITLE,\n        parent: 'legend',\n        child: 'title'\n    },\n    {\n        property: Property.LEGEND_TITLECOLOR,\n        parent: 'legend',\n        child: 'titleColor'\n    },\n    {\n        property: Property.LEGEND_TITLEFONT,\n        parent: 'legend',\n        child: 'titleFont'\n    },\n    {\n        property: Property.LEGEND_TITLEFONTSIZE,\n        parent: 'legend',\n        child: 'titleFontSize'\n    },\n    {\n        property: Property.LEGEND_TITLEFONTWEIGHT,\n        parent: 'legend',\n        child: 'titleFontWeight'\n    }\n];\nvar NESTED_ENCODING_INDEX = exports.NESTED_ENCODING_PROPERTIES.reduce(function (m, nestedProp) {\n    m[nestedProp.property] = nestedProp;\n    return m;\n}, {});\nvar NESTED_ENCODING_PROPERTY_PARENT_INDEX = exports.NESTED_ENCODING_PROPERTIES.reduce(function (m, nestedProp) {\n    var parent = nestedProp.parent;\n    // if the parent does not exist in m yet, add it as a key in m with empty [] as value\n    if (!(parent in m)) {\n        m[parent] = [];\n    }\n    m[nestedProp.parent].push(nestedProp);\n    return m;\n}, {}); // as Dict<Array<String>>);\nexports.SCALE_PROPERTIES = NESTED_ENCODING_PROPERTY_PARENT_INDEX['scale'].map(function (nestedProp) {\n    return nestedProp.property;\n});\nvar ENCODING_INDEX = exports.ENCODING_PROPERTIES.reduce(function (m, prop) {\n    m[prop] = prop;\n    return m;\n}, {});\nfunction isEncodingProperty(prop) {\n    return ENCODING_INDEX[prop] !== undefined;\n}\nexports.isEncodingProperty = isEncodingProperty;\nfunction getNestedEncodingProperty(prop) {\n    return NESTED_ENCODING_INDEX[prop];\n}\nexports.getNestedEncodingProperty = getNestedEncodingProperty;\nfunction getNestedEncodingPropertyChildren(parent) {\n    return NESTED_ENCODING_PROPERTY_PARENT_INDEX[parent];\n}\nexports.getNestedEncodingPropertyChildren = getNestedEncodingPropertyChildren;\nfunction isNestedEncodingProperty(prop) {\n    return prop in NESTED_ENCODING_INDEX;\n}\nexports.isNestedEncodingProperty = isNestedEncodingProperty;\nvar SUPPORTED_SCALE_PROPERTY = [\n    {\n        property: 'bandSize',\n        supportedScaleType: [\n            scale_1.ScaleType.ORDINAL\n        ]\n    },\n    {\n        property: 'clamp',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'domain',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.QUANTILE,\n            scale_1.ScaleType.QUANTIZE,\n            scale_1.ScaleType.ORDINAL,\n            scale_1.ScaleType.SQRT,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'exponent',\n        supportedScaleType: [\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.SQRT\n        ]\n    },\n    {\n        property: 'nice',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'range',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.QUANTILE,\n            scale_1.ScaleType.QUANTIZE,\n            scale_1.ScaleType.ORDINAL,\n            scale_1.ScaleType.SQRT,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'round',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.SQRT,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'useRawDomain',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.LOG,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.QUANTILE,\n            scale_1.ScaleType.QUANTIZE,\n            scale_1.ScaleType.ORDINAL,\n            scale_1.ScaleType.SQRT,\n            scale_1.ScaleType.TIME,\n            scale_1.ScaleType.UTC\n        ]\n    },\n    {\n        property: 'zero',\n        supportedScaleType: [\n            scale_1.ScaleType.LINEAR,\n            scale_1.ScaleType.POW,\n            scale_1.ScaleType.SQRT\n        ]\n    }\n];\nexports.SUPPORTED_SCALE_PROPERTY_INDEX = SUPPORTED_SCALE_PROPERTY.reduce(function (m, scaleProp) {\n    var prop = scaleProp.property;\n    m[prop] = scaleProp.supportedScaleType;\n    return m;\n}, {});\n//# sourceMappingURL=property.js.map",
    "\"use strict\";\nvar scale_1 = require('vega-lite/src/scale');\nvar timeunit_1 = require('vega-lite/src/timeunit');\nvar type_1 = require('vega-lite/src/type');\nvar enumspec_1 = require('../enumspec');\nvar util_1 = require('../util');\nfunction isDimension(encQ) {\n    return util_1.contains([type_1.Type.NOMINAL, type_1.Type.ORDINAL], encQ.type) ||\n        (!enumspec_1.isEnumSpec(encQ.bin) && !!encQ.bin) ||\n        (!enumspec_1.isEnumSpec(encQ.timeUnit) && !!encQ.timeUnit); // surely T type\n}\nexports.isDimension = isDimension;\nfunction isMeasure(encQ) {\n    return (encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin) ||\n        (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit);\n}\nexports.isMeasure = isMeasure;\n/**\n *  Returns the true scale type of an encoding.\n *  @returns {ScaleType} If the scale type was not specified, it is inferred from the encoding's Type.\n *  @returns {undefined} If the scale type was not specified and Type (or TimeUnit if applicable) is an EnumSpec, there is no clear scale type\n */\nfunction scaleType(encQ) {\n    var scale = encQ.scale === true || encQ.scale === enumspec_1.SHORT_ENUM_SPEC ? {} : encQ.scale;\n    var type = encQ.type;\n    var timeUnit = encQ.timeUnit;\n    if (scale && scale.type !== undefined) {\n        return scale.type;\n    }\n    if (enumspec_1.isEnumSpec(type)) {\n        return undefined;\n    }\n    /* istanbul ignore else */\n    if (type === type_1.Type.QUANTITATIVE) {\n        return scale_1.ScaleType.LINEAR;\n    }\n    else if (type === type_1.Type.ORDINAL || type === type_1.Type.NOMINAL) {\n        return scale_1.ScaleType.ORDINAL;\n    }\n    else if (type === type_1.Type.TEMPORAL) {\n        if (timeUnit !== undefined) {\n            if (enumspec_1.isEnumSpec(timeUnit)) {\n                return undefined;\n            }\n            return timeunit_1.defaultScaleType(timeUnit);\n        }\n        else {\n            return scale_1.ScaleType.TIME;\n        }\n    }\n    else {\n        throw new Error('Unsupported type: ' + type + ' in scaleType');\n    }\n}\nexports.scaleType = scaleType;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar util_1 = require('datalib/src/util');\nvar util_2 = require('../util');\nexports.REPLACE_BLANK_FIELDS = { '*': '' };\nexports.REPLACE_XY_CHANNELS = { x: 'xy', y: 'xy' };\nexports.REPLACE_FACET_CHANNELS = { row: 'facet', column: 'facet' };\nexports.REPLACE_MARK_STYLE_CHANNELS = { color: 'style', opacity: 'style', shape: 'style', size: 'style' };\nfunction isExtendedGroupBy(g) {\n    return util_1.isObject(g) && !!g['property'];\n}\nexports.isExtendedGroupBy = isExtendedGroupBy;\nfunction parse(groupBy, include, replaceIndex) {\n    groupBy.forEach(function (grpBy) {\n        if (isExtendedGroupBy(grpBy)) {\n            include[grpBy.property] = true;\n            replaceIndex[grpBy.property] = grpBy.replace;\n        }\n        else {\n            include[grpBy] = true;\n        }\n    });\n}\nexports.parse = parse;\nfunction toString(groupBy) {\n    if (util_1.isArray(groupBy)) {\n        return groupBy.map(function (g) {\n            if (isExtendedGroupBy(g)) {\n                if (g.replace) {\n                    var replaceIndex = util_2.keys(g.replace).reduce(function (index, valFrom) {\n                        var valTo = g.replace[valFrom];\n                        (index[valTo] = index[valTo] || []).push(valFrom);\n                        return index;\n                    }, {});\n                    return g.property + '[' + util_2.keys(replaceIndex).map(function (valTo) {\n                        var valsFrom = replaceIndex[valTo].sort();\n                        return valsFrom.join(',') + '=>' + valTo;\n                    }).join(';') + ']';\n                }\n                return g.property;\n            }\n            return g;\n        }).join(',');\n    }\n    else {\n        return groupBy;\n    }\n}\nexports.toString = toString;\n//# sourceMappingURL=groupby.js.map",
    "\"use strict\";\nvar config_1 = require('../config');\nvar generate_1 = require('../generate');\nvar nest_1 = require('../nest');\nvar ranking_1 = require('../ranking/ranking');\nvar util_1 = require('../util');\nexports.encoding = require('./encoding');\nexports.groupBy = require('./groupby');\nexports.shorthand = require('./shorthand');\nexports.spec = require('./spec');\nexports.transform = require('./transform');\nfunction query(q, schema, config) {\n    // 1. Normalize non-nested `groupBy` to always have `groupBy` inside `nest`\n    //    and merge config with the following precedence\n    //    query.config > config > DEFAULT_QUERY_CONFIG\n    q = util_1.extend({}, normalize(q), {\n        config: util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, config, q.config)\n    });\n    // 2. Generate\n    var answerSet = generate_1.generate(q.spec, schema, q.config);\n    var nestedAnswerSet = nest_1.nest(answerSet, q);\n    var result = ranking_1.rank(nestedAnswerSet, q, schema, 0);\n    return {\n        query: q,\n        result: result\n    };\n}\nexports.query = query;\n/**\n * Normalize the non-nested version of the query to a standardize nested\n */\nfunction normalize(q) {\n    if (q.groupBy) {\n        var nest_2 = {\n            groupBy: q.groupBy\n        };\n        if (q.orderBy) {\n            nest_2.orderGroupBy = q.orderBy;\n        }\n        var normalizedQ = {\n            spec: util_1.duplicate(q.spec),\n            nest: [nest_2],\n        };\n        if (q.chooseBy) {\n            normalizedQ.chooseBy = q.chooseBy;\n        }\n        if (q.config) {\n            normalizedQ.config = q.config;\n        }\n        return normalizedQ;\n    }\n    return util_1.duplicate(q); // We will cause side effect to q.spec in SpecQueryModel.build\n}\nexports.normalize = normalize;\n//# sourceMappingURL=query.js.map",
    "\"use strict\";\nvar type_1 = require('vega-lite/src/type');\nvar util_1 = require('datalib/src/util');\nvar spec_1 = require('./spec');\nvar enumspec_1 = require('../enumspec');\nvar property_1 = require('../property');\nvar util_2 = require('../util');\nfunction getReplacerIndex(replaceIndex) {\n    return util_2.keys(replaceIndex).reduce(function (fnIndex, prop) {\n        fnIndex[prop] = getReplacer(replaceIndex[prop]);\n        return fnIndex;\n    }, {});\n}\nexports.getReplacerIndex = getReplacerIndex;\nfunction getReplacer(replace) {\n    return function (s) {\n        if (replace[s] !== undefined) {\n            return replace[s];\n        }\n        return s;\n    };\n}\nexports.getReplacer = getReplacer;\nfunction value(v, replacer) {\n    if (enumspec_1.isEnumSpec(v)) {\n        // Return the enum array if it's a full enum spec, or just return SHORT_ENUM_SPEC for short ones.\n        if (v.enum) {\n            return enumspec_1.SHORT_ENUM_SPEC + JSON.stringify(v.enum);\n        }\n        else {\n            return enumspec_1.SHORT_ENUM_SPEC;\n        }\n    }\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.value = value;\nfunction replace(v, replacer) {\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.replace = replace;\nexports.INCLUDE_ALL = \n// TODO: remove manual STACK, FILTER, CALCULATE concat once we really support enumerating it.\nproperty_1.DEFAULT_PROPERTY_PRECEDENCE.concat([property_1.Property.CALCULATE, property_1.Property.FILTER, property_1.Property.FILTERINVALID, property_1.Property.STACK])\n    .reduce(function (m, prop) {\n    m[prop] = true;\n    return m;\n}, {});\nfunction vlSpec(vlspec, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = {}; }\n    var specQ = spec_1.fromSpec(vlspec);\n    return spec(specQ);\n}\nexports.vlSpec = vlSpec;\nexports.PROPERTY_SUPPORTED_CHANNELS = {\n    axis: { x: true, y: true, row: true, column: true },\n    legend: { color: true, opacity: true, size: true, shape: true },\n    scale: { x: true, y: true, color: true, opacity: true, row: true, column: true, size: true, shape: true },\n    sort: { x: true, y: true, path: true, order: true }\n};\n/**\n * Returns a shorthand for a spec query\n * @param specQ a spec query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction spec(specQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = {}; }\n    var parts = [];\n    if (include[property_1.Property.MARK]) {\n        parts.push(value(specQ.mark, replace[property_1.Property.MARK]));\n    }\n    if (specQ.transform) {\n        if (include[property_1.Property.CALCULATE]) {\n            if (specQ.transform.calculate !== undefined) {\n                parts.push('calculate:' + calculate(specQ.transform.calculate));\n            }\n        }\n        if (include[property_1.Property.FILTER]) {\n            if (specQ.transform.filter !== undefined) {\n                parts.push('filter:' + JSON.stringify(specQ.transform.filter));\n            }\n        }\n        if (include[property_1.Property.FILTERINVALID]) {\n            if (specQ.transform.filterInvalid !== undefined) {\n                parts.push('filterInvalid:' + specQ.transform.filterInvalid);\n            }\n        }\n    }\n    // TODO: extract this to its own stack method\n    if (include[property_1.Property.STACK]) {\n        var _stack = spec_1.stack(specQ);\n        if (_stack) {\n            // TODO: Refactor this once we have child stack property.\n            // Exclude type since we don't care about type in stack\n            var includeExceptType = util_2.extend({}, include, { type: false });\n            var field = fieldDef(_stack.fieldEncQ, includeExceptType, replace);\n            var groupby = fieldDef(_stack.groupByEncQ, includeExceptType, replace);\n            parts.push('stack={field:' + field + ',' +\n                (groupby ? 'by:' + groupby + ',' : '') +\n                'offset:' + _stack.offset + '}');\n        }\n    }\n    parts.push(specQ.encodings.reduce(function (encQs, encQ) {\n        // Exclude encoding mapping with autoCount=false as they are basically disabled.\n        if (encQ.autoCount !== false) {\n            var str = encoding(encQ, include, replace);\n            if (str) {\n                encQs.push(str);\n            }\n        }\n        return encQs;\n    }, [])\n        .sort() // sort at the end to ignore order\n        .join('|'));\n    return parts.join('|');\n}\nexports.spec = spec;\nfunction calculate(formulaArr) {\n    return formulaArr.map(function (calculateItem) {\n        return \"{\" + calculateItem.field + \":\" + calculateItem.expr + \"}\";\n    }).join(',');\n}\nexports.calculate = calculate;\n/**\n * Returns a shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction encoding(encQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = {}; }\n    var parts = [];\n    if (include[property_1.Property.CHANNEL]) {\n        parts.push(value(encQ.channel, replace[property_1.Property.CHANNEL]));\n    }\n    var fieldDefStr = fieldDef(encQ, include, replace);\n    if (fieldDefStr) {\n        parts.push(fieldDefStr);\n    }\n    return parts.join(':');\n}\nexports.encoding = encoding;\n/**\n * Returns a field definiton shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction fieldDef(encQ, include, replacer) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replacer === void 0) { replacer = {}; }\n    var fn = null, fnEnumIndex = null;\n    /** Encoding properties e.g., Scale, Axis, Legend */\n    var props = [];\n    if (include[property_1.Property.AGGREGATE] && encQ.autoCount === false) {\n        return '-';\n    }\n    else if (include[property_1.Property.AGGREGATE] && encQ.aggregate && !enumspec_1.isEnumSpec(encQ.aggregate)) {\n        fn = replace(encQ.aggregate, replacer[property_1.Property.AGGREGATE]);\n    }\n    else if (include[property_1.Property.AGGREGATE] && encQ.autoCount && !enumspec_1.isEnumSpec(encQ.autoCount)) {\n        fn = replace('count', replacer[property_1.Property.AGGREGATE]);\n        ;\n    }\n    else if (include[property_1.Property.TIMEUNIT] && encQ.timeUnit && !enumspec_1.isEnumSpec(encQ.timeUnit)) {\n        fn = replace(encQ.timeUnit, replacer[property_1.Property.TIMEUNIT]);\n    }\n    else if (include[property_1.Property.BIN] && encQ.bin && !enumspec_1.isEnumSpec(encQ.bin)) {\n        fn = 'bin';\n        // TODO(https://github.com/uwdata/compassql/issues/97):\n        // extract this as a method that support other bin properties\n        if (include[property_1.Property.BIN_MAXBINS] && encQ.bin['maxbins']) {\n            props.push({\n                key: 'maxbins',\n                value: value(encQ.bin['maxbins'], replacer[property_1.Property.BIN_MAXBINS])\n            });\n        }\n    }\n    else {\n        for (var _i = 0, _a = [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN]; _i < _a.length; _i++) {\n            var prop = _a[_i];\n            if (include[prop] && encQ[prop] && enumspec_1.isEnumSpec(encQ[prop])) {\n                fn = enumspec_1.SHORT_ENUM_SPEC + '';\n                // assign fnEnumIndex[prop] = array of enum values or just \"?\" if it is SHORT_ENUM_SPEC\n                fnEnumIndex = fnEnumIndex || {};\n                fnEnumIndex[prop] = encQ[prop].enum || encQ[prop];\n                if (prop === property_1.Property.BIN) {\n                    // TODO(https://github.com/uwdata/compassql/issues/97):\n                    // extract this as a method that support other bin properties\n                    if (include[property_1.Property.BIN_MAXBINS] && encQ.bin['maxbins']) {\n                        props.push({\n                            key: 'maxbins',\n                            value: value(encQ.bin['maxbins'], replacer[property_1.Property.BIN_MAXBINS])\n                        });\n                    }\n                }\n            }\n        }\n        if (fnEnumIndex && encQ.hasFn) {\n            fnEnumIndex.hasFn = true;\n        }\n    }\n    var _loop_1 = function(nestedPropParent) {\n        if (!enumspec_1.isEnumSpec(encQ.channel) && !exports.PROPERTY_SUPPORTED_CHANNELS[nestedPropParent][encQ.channel]) {\n            return \"continue\";\n        }\n        if (include[nestedPropParent]) {\n            if (encQ[nestedPropParent] && !enumspec_1.isEnumSpec(encQ[nestedPropParent])) {\n                // `sort` can be a string (ascending/descending).\n                if (util_1.isString(encQ[nestedPropParent])) {\n                    props.push({\n                        key: nestedPropParent + '',\n                        value: JSON.stringify(encQ[nestedPropParent])\n                    });\n                }\n                else {\n                    var nestedProps = property_1.getNestedEncodingPropertyChildren(nestedPropParent);\n                    var nestedPropChildren = nestedProps.reduce(function (p, nestedProp) {\n                        if (include[nestedProp.property] && encQ[nestedPropParent][nestedProp.child] !== undefined) {\n                            p[nestedProp.child] = replace(encQ[nestedPropParent][nestedProp.child], replacer[nestedProp.property]);\n                        }\n                        return p;\n                    }, {});\n                    if (util_2.keys(nestedPropChildren).length > 0) {\n                        props.push({\n                            key: nestedPropParent + '',\n                            value: JSON.stringify(nestedPropChildren)\n                        });\n                    }\n                }\n            }\n            else if (encQ[nestedPropParent] === false || encQ[nestedPropParent] === null) {\n                // `scale`, `axis`, `legend` can be false/null.\n                props.push({\n                    key: nestedPropParent + '',\n                    value: false\n                });\n            }\n        }\n    };\n    for (var _b = 0, _c = [property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND]; _b < _c.length; _b++) {\n        var nestedPropParent = _c[_b];\n        var state_1 = _loop_1(nestedPropParent);\n        if (state_1 === \"continue\") continue;\n    }\n    // field\n    var fieldAndParams = include[property_1.Property.FIELD] ? value(encQ.field || '*', replacer[property_1.Property.FIELD]) : '...';\n    // type\n    if (include[property_1.Property.TYPE]) {\n        if (enumspec_1.isEnumSpec(encQ.type)) {\n            fieldAndParams += ',' + value(encQ.type, replacer[property_1.Property.TYPE]);\n        }\n        else {\n            var typeShort = ((encQ.type || type_1.Type.QUANTITATIVE) + '').substr(0, 1);\n            fieldAndParams += ',' + value(typeShort, replacer[property_1.Property.TYPE]);\n        }\n    }\n    // encoding properties\n    fieldAndParams += props.map(function (p) { return ',' + p.key + '=' + p.value; }).join('');\n    if (fn) {\n        return fn + (fnEnumIndex ? JSON.stringify(fnEnumIndex) : '') + '(' + fieldAndParams + ')';\n    }\n    return fieldAndParams;\n}\nexports.fieldDef = fieldDef;\n//# sourceMappingURL=shorthand.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar stack_1 = require('vega-lite/src/stack');\nvar enumspec_1 = require('../enumspec');\nvar property_1 = require('../property');\nvar util_1 = require('../util');\n/**\n * Convert a Vega-Lite's ExtendedUnitSpec into a CompassQL's SpecQuery\n * @param {ExtendedUnitSpec} spec\n * @returns\n */\nfunction fromSpec(spec) {\n    return util_1.extend(spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, {\n        mark: spec.mark,\n        encodings: util_1.keys(spec.encoding).map(function (channel) {\n            var encQ = { channel: channel };\n            var channelDef = spec.encoding[channel];\n            for (var _i = 0, ENCODING_PROPERTIES_1 = property_1.ENCODING_PROPERTIES; _i < ENCODING_PROPERTIES_1.length; _i++) {\n                var prop = ENCODING_PROPERTIES_1[_i];\n                if (!property_1.isNestedEncodingProperty(prop) && channelDef[prop] !== undefined) {\n                    encQ[prop] = channelDef[prop];\n                }\n                // Currently scale, axis, legend only support boolean, but not null.\n                // Therefore convert null to false.\n                if (util_1.contains([property_1.Property.SCALE, property_1.Property.AXIS, property_1.Property.LEGEND], prop) && encQ[prop] === null) {\n                    encQ[prop] = false;\n                }\n            }\n            return encQ;\n        })\n    }, spec.config ? { config: spec.config } : {});\n}\nexports.fromSpec = fromSpec;\nfunction isAggregate(specQ) {\n    return util_1.some(specQ.encodings, function (encQ) {\n        return (!enumspec_1.isEnumSpec(encQ.aggregate) && !!encQ.aggregate) || encQ.autoCount === true;\n    });\n}\nexports.isAggregate = isAggregate;\n/**\n * @return the stack offset type for the specQuery\n */\nfunction stack(specQ) {\n    var config = specQ.config;\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains([stack_1.StackOffset.NONE, null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], specQ.mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!isAggregate(specQ)) {\n        return null;\n    }\n    var stackByChannels = specQ.encodings.reduce(function (sc, encQ) {\n        if (util_1.contains(channel_1.STACK_GROUP_CHANNELS, encQ.channel) && !encQ.aggregate) {\n            sc.push(encQ.channel);\n        }\n        return sc;\n    }, []);\n    if (stackByChannels.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var xEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.X ? encQ : null);\n    }, null);\n    var yEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.Y ? encQ : null);\n    }, null);\n    var xIsAggregate = !!xEncQ && (!!xEncQ.aggregate || !!xEncQ.autoCount);\n    var yIsAggregate = !!yEncQ && (!!yEncQ.aggregate || !!yEncQ.autoCount);\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (!!yEncQ ? channel_1.Y : null) : (!!xEncQ ? channel_1.X : null),\n            groupByEncQ: xIsAggregate ? yEncQ : xEncQ,\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            fieldEncQ: xIsAggregate ? xEncQ : yEncQ,\n            stackByChannels: stackByChannels,\n            offset: stacked || stack_1.StackOffset.ZERO\n        };\n    }\n    return null;\n}\nexports.stack = stack;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\n//# sourceMappingURL=transform.js.map",
    "\"use strict\";\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar type_1 = require('vega-lite/src/type');\nvar util_1 = require('../util');\nvar encoding_1 = require('../query/encoding');\nexports.name = 'aggregationQuality';\nfunction score(specM, schema, opt) {\n    var feature = aggregationQualityFeature(specM, schema, opt);\n    return {\n        score: feature.score,\n        features: [feature]\n    };\n}\nexports.score = score;\nfunction aggregationQualityFeature(specM, schema, opt) {\n    var encodings = specM.getEncodings();\n    if (specM.isAggregate()) {\n        var isRawContinuous = function (encQ) {\n            return (encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin && !encQ.aggregate && !encQ.autoCount) ||\n                (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit);\n        };\n        if (util_1.some(encodings, isRawContinuous)) {\n            // These are plots that pollute continuous fields as dimension.\n            // They are often intermediate visualizations rather than what users actually want.\n            return {\n                type: exports.name,\n                score: 0.1,\n                feature: 'Aggregate with raw continuous'\n            };\n        }\n        if (util_1.some(encodings, encoding_1.isDimension)) {\n            var hasCount = util_1.some(encodings, function (encQ) {\n                return encQ.aggregate === aggregate_1.AggregateOp.COUNT || encQ.autoCount === true;\n            });\n            var hasBin = util_1.some(encodings, function (encQ) {\n                return !!encQ.bin;\n            });\n            if (hasCount) {\n                // If there is count, we might add additional count field, making it a little less simple\n                // then when we just apply aggregate to Q field\n                return {\n                    type: exports.name,\n                    score: 0.8,\n                    feature: 'Aggregate with count'\n                };\n            }\n            else if (hasBin) {\n                // This is not as good as binning all the Q and show heatmap\n                return {\n                    type: exports.name,\n                    score: 0.7,\n                    feature: 'Aggregate with bin but without count'\n                };\n            }\n            else {\n                return {\n                    type: exports.name,\n                    score: 0.9,\n                    feature: 'Aggregate without count and without bin'\n                };\n            }\n        }\n        // no dimension -- often not very useful\n        return {\n            type: exports.name,\n            score: 0.3,\n            feature: 'Aggregate without dimension'\n        };\n    }\n    else {\n        if (util_1.some(encodings, encoding_1.isMeasure)) {\n            // raw plots with measure -- simplest of all!\n            return {\n                type: exports.name,\n                score: 1,\n                feature: 'Raw with measure'\n            };\n        }\n        // raw plots with no measure -- often a lot of occlusion\n        return {\n            type: exports.name,\n            score: 0.2,\n            feature: 'Raw without measure'\n        };\n    }\n}\n//# sourceMappingURL=aggregation.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar config_1 = require('../../config');\nvar shorthand_1 = require('../../query/shorthand');\nvar util_1 = require('../../util');\nvar effectiveness_1 = require('./effectiveness');\nvar type_1 = require('./type');\n/**\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\nvar TypeChannelScore;\n(function (TypeChannelScore) {\n    TypeChannelScore.TYPE_CHANNEL = 'typeChannel';\n    function init() {\n        var SCORE = {};\n        var ORDERED_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            size: -0.575,\n            color: -0.725,\n            opacity: -0.85,\n            text: -0.875,\n            row: -0.9,\n            column: -0.9,\n            shape: -2.5,\n            detail: -3\n        };\n        [type_1.Q, type_1.BIN_Q, type_1.T, type_1.TIMEUNIT_T, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\n            util_1.keys(ORDERED_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[featurize(type, channel)] = ORDERED_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        // Penalize row/column for bin quantitative / timeUnit_temporal / O less\n        [type_1.BIN_Q, type_1.TIMEUNIT_T, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\n            [channel_1.Channel.ROW, channel_1.Channel.COLUMN].forEach(function (channel) {\n                SCORE[featurize(type, channel)] += 0.15;\n            });\n        });\n        var NOMINAL_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            color: -0.6,\n            shape: -0.65,\n            row: -0.7,\n            column: -0.7,\n            text: -0.8,\n            size: -1.8,\n            detail: -2,\n            opacity: -2.1\n        };\n        util_1.keys(NOMINAL_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n            SCORE[featurize(type_1.N, channel)] = NOMINAL_TYPE_CHANNEL_SCORE[channel];\n        });\n        return SCORE;\n    }\n    TypeChannelScore.init = init;\n    function featurize(type, channel) {\n        return type + '_' + channel;\n    }\n    TypeChannelScore.featurize = featurize;\n    function getScore(specM, schema, opt) {\n        var encodingQueryByField = specM.getEncodings().reduce(function (m, encQ) {\n            var fieldKey = shorthand_1.fieldDef(encQ);\n            (m[fieldKey] = m[fieldKey] || []).push(encQ);\n            return m;\n        }, {});\n        var features = [];\n        util_1.forEach(encodingQueryByField, function (encQs) {\n            var bestFieldFeature = encQs.reduce(function (best, encQ) {\n                var type = type_1.getExtendedType(encQ);\n                var feature = featurize(type, encQ.channel);\n                var featureScore = effectiveness_1.getFeatureScore(TypeChannelScore.TYPE_CHANNEL, feature);\n                if (best === null || featureScore.score > best.score) {\n                    return featureScore;\n                }\n                return best;\n            }, null);\n            features.push(bestFieldFeature);\n            // TODO: add plus for over-encoding of one field\n        });\n        return features;\n    }\n    TypeChannelScore.getScore = getScore;\n})(TypeChannelScore = exports.TypeChannelScore || (exports.TypeChannelScore = {}));\nvar PreferredAxisScore;\n(function (PreferredAxisScore) {\n    PreferredAxisScore.PREFERRED_AXIS = 'preferredAxis';\n    // FIXME support doing this at runtime\n    function init(opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        var preferredAxes = [{\n                feature: type_1.BIN_Q,\n                opt: 'preferredBinAxis'\n            }, {\n                feature: type_1.T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_O,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.O,\n                opt: 'preferredOrdinalAxis'\n            }, {\n                feature: type_1.N,\n                opt: 'preferredNominalAxis'\n            }];\n        preferredAxes.forEach(function (preferredAxis) {\n            if (opt[preferredAxis.opt] === channel_1.Channel.X) {\n                // penalize the other axis\n                score[preferredAxis.feature + '_' + channel_1.Channel.Y] = -0.01;\n            }\n            else if (opt[preferredAxis.opt] === channel_1.Channel.Y) {\n                // penalize the other axis\n                score[preferredAxis.feature + '_' + channel_1.Channel.X] = -0.01;\n            }\n        });\n        return score;\n    }\n    PreferredAxisScore.init = init;\n    function featurize(type, channel) {\n        return type + '_' + channel;\n    }\n    PreferredAxisScore.featurize = featurize;\n    function getScore(specM, schema, opt) {\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var type = type_1.getExtendedType(encQ);\n            var feature = featurize(type, encQ.channel);\n            var featureScore = effectiveness_1.getFeatureScore(PreferredAxisScore.PREFERRED_AXIS, feature);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    }\n    PreferredAxisScore.getScore = getScore;\n})(PreferredAxisScore = exports.PreferredAxisScore || (exports.PreferredAxisScore = {}));\nvar PreferredFacetScore;\n(function (PreferredFacetScore) {\n    PreferredFacetScore.PREFERRED_FACET = 'preferredFacet';\n    // FIXME support doing this at runtime\n    function init(opt) {\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        if (opt.preferredFacet === channel_1.Channel.ROW) {\n            // penalize the other axis\n            score[channel_1.Channel.COLUMN] = -0.01;\n        }\n        else if (opt.preferredFacet === channel_1.Channel.COLUMN) {\n            // penalize the other axis\n            score[channel_1.Channel.ROW] = -0.01;\n        }\n        return score;\n    }\n    PreferredFacetScore.init = init;\n    function getScore(specM, schema, opt) {\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var featureScore = effectiveness_1.getFeatureScore(PreferredFacetScore.PREFERRED_FACET, encQ.channel);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    }\n    PreferredFacetScore.getScore = getScore;\n})(PreferredFacetScore = exports.PreferredFacetScore || (exports.PreferredFacetScore = {}));\nvar MarkChannelScore;\n(function (MarkChannelScore) {\n    // Penalty for certain channel for certain mark types\n    MarkChannelScore.MARK_CHANNEL = 'markChannel';\n    function init() {\n        return {\n            bar_size: -2,\n            tick_size: -2\n        };\n    }\n    MarkChannelScore.init = init;\n    function getScore(specM, schema, opt) {\n        var mark = specM.getMark();\n        return specM.getEncodings().reduce(function (featureScores, encQ) {\n            var feature = mark + '_' + encQ.channel;\n            var featureScore = effectiveness_1.getFeatureScore(MarkChannelScore.MARK_CHANNEL, feature);\n            if (featureScore) {\n                featureScores.push(featureScore);\n            }\n            return featureScores;\n        }, []);\n    }\n    MarkChannelScore.getScore = getScore;\n})(MarkChannelScore = exports.MarkChannelScore || (exports.MarkChannelScore = {}));\n/**\n * Penalize if facet channels are the only dimensions\n */\nvar DimensionScore;\n(function (DimensionScore) {\n    DimensionScore.DIMENSION = 'dimension';\n    function init() {\n        return {\n            row: -2,\n            column: -2,\n            color: 0,\n            opacity: 0,\n            size: 0,\n            shape: 0\n        };\n    }\n    DimensionScore.init = init;\n    function getScore(specM, schema, opt) {\n        if (specM.isAggregate()) {\n            specM.getEncodings().reduce(function (maxFScore, encQ) {\n                if (!encQ.aggregate && !encQ.autoCount) {\n                    var featureScore = effectiveness_1.getFeatureScore(DimensionScore.DIMENSION, encQ.channel + '');\n                    if (featureScore.score > maxFScore.score) {\n                        return featureScore;\n                    }\n                }\n                return maxFScore;\n            }, { type: DimensionScore.DIMENSION, feature: 'No Dimension', score: -5 });\n        }\n        return [];\n    }\n    DimensionScore.getScore = getScore;\n})(DimensionScore = exports.DimensionScore || (exports.DimensionScore = {}));\n//# sourceMappingURL=channel.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar mark_1 = require('./mark');\nexports.FEATURE_INDEX = {};\nvar FEATURE_FACTORIES = [];\nfunction getFeatureScore(type, feature) {\n    var score = exports.FEATURE_INDEX[type][feature];\n    if (score !== undefined) {\n        return {\n            score: score,\n            type: type,\n            feature: feature\n        };\n    }\n    return null;\n}\nexports.getFeatureScore = getFeatureScore;\nfunction addFeatureFactory(factory) {\n    FEATURE_FACTORIES.push(factory);\n    exports.FEATURE_INDEX[factory.type] = factory.init();\n}\nexports.addFeatureFactory = addFeatureFactory;\naddFeatureFactory({\n    type: channel_1.TypeChannelScore.TYPE_CHANNEL,\n    init: channel_1.TypeChannelScore.init,\n    getScore: channel_1.TypeChannelScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.PreferredAxisScore.PREFERRED_AXIS,\n    init: channel_1.PreferredAxisScore.init,\n    getScore: channel_1.PreferredAxisScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.PreferredFacetScore.PREFERRED_FACET,\n    init: channel_1.PreferredFacetScore.init,\n    getScore: channel_1.PreferredFacetScore.getScore\n});\naddFeatureFactory({\n    type: channel_1.MarkChannelScore.MARK_CHANNEL,\n    init: channel_1.MarkChannelScore.init,\n    getScore: channel_1.MarkChannelScore.getScore\n});\naddFeatureFactory({\n    type: mark_1.MarkScore.MARK_SCORE,\n    init: mark_1.MarkScore.init,\n    getScore: mark_1.MarkScore.getScore\n});\n// TODO: x/y, row/column preference\n// TODO: stacking\n// TODO: Channel, Cardinality\n// TODO: Penalize over encoding\nfunction default_1(specM, schema, opt) {\n    var features = FEATURE_FACTORIES.reduce(function (f, factory) {\n        var scores = factory.getScore(specM, schema, opt);\n        return f.concat(scores);\n    }, []);\n    return {\n        score: features.reduce(function (s, f) {\n            return s + f.score;\n        }, 0),\n        features: features\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = default_1;\n//# sourceMappingURL=effectiveness.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nvar util_1 = require('../../util');\nvar effectiveness_1 = require('./effectiveness');\nvar type_1 = require('./type');\nvar MarkScore;\n(function (MarkScore) {\n    MarkScore.MARK_SCORE = 'markScore';\n    function featurize(xType, yType, hasOcclusion, mark) {\n        return xType + '_' + yType + '_' + hasOcclusion + '_' + mark;\n    }\n    MarkScore.featurize = featurize;\n    function init() {\n        var MEASURES = [type_1.Q, type_1.T];\n        var DISCRETE = [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O, type_1.N];\n        var DISCRETE_OR_NONE = DISCRETE.concat([type_1.NONE]);\n        var SCORE = {};\n        // QxQ\n        MEASURES.forEach(function (xType) {\n            MEASURES.forEach(function (yType) {\n                // has occlusion\n                var occludedQQMark = {\n                    point: 0,\n                    text: -0.2,\n                    tick: -0.5,\n                    rect: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(occludedQQMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                // no occlusion\n                // TODO: possible to use connected scatter plot\n                var noOccludedQQMark = {\n                    point: 0,\n                    text: -0.2,\n                    tick: -0.5,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQQMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n        });\n        // DxQ, QxD\n        MEASURES.forEach(function (xType) {\n            // HAS OCCLUSION\n            DISCRETE_OR_NONE.forEach(function (yType) {\n                var occludedDimensionMeasureMark = {\n                    tick: 0,\n                    point: -0.2,\n                    text: -0.5,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, true, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            [type_1.TIMEUNIT_T].forEach(function (yType) {\n                var occludedDimensionMeasureMark = {\n                    // For Time Dimension with time scale, tick is not good\n                    point: 0,\n                    text: -0.5,\n                    tick: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, true, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            // NO OCCLUSION\n            [type_1.NONE, type_1.N, type_1.O].forEach(function (yType) {\n                var noOccludedQxN = {\n                    bar: 0,\n                    point: -0.2,\n                    tick: -0.25,\n                    text: -0.3,\n                    // Line / Area can mislead trend for N\n                    line: -2,\n                    area: -2,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxN, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            [type_1.BIN_Q].forEach(function (yType) {\n                var noOccludedQxBinQ = {\n                    bar: 0,\n                    point: -0.2,\n                    tick: -0.25,\n                    text: -0.3,\n                    // Line / Area isn't the best fit for bin\n                    line: -0.5,\n                    area: -0.5,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n            [type_1.TIMEUNIT_T, type_1.TIMEUNIT_O].forEach(function (yType) {\n                // For aggregate / surely no occlusion plot, Temporal with time or ordinal\n                // are not that different.\n                var noOccludedQxBinQ = {\n                    line: 0,\n                    area: -0.1,\n                    bar: -0.2,\n                    point: -0.3,\n                    tick: -0.35,\n                    text: -0.4,\n                    // Non-sense to use rule here\n                    rule: -2.5\n                };\n                util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                    // also do the inverse\n                    var feature2 = featurize(yType, xType, false, mark);\n                    SCORE[feature2] = score;\n                });\n            });\n        });\n        [type_1.TIMEUNIT_T].forEach(function (xType) {\n            [type_1.TIMEUNIT_T].forEach(function (yType) {\n                // has occlusion\n                var ttMark = {\n                    point: 0,\n                    rect: -0.1,\n                    text: -0.5,\n                    tick: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                // No difference between has occlusion and no occlusion\n                // as most of the time, it will be the occluded case.\n                util_1.forEach(ttMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(ttMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n            DISCRETE_OR_NONE.forEach(function (yType) {\n                // has occlusion\n                var tdMark = {\n                    tick: 0,\n                    point: -0.2,\n                    text: -0.5,\n                    rect: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                // No difference between has occlusion and no occlusion\n                // as most of the time, it will be the occluded case.\n                util_1.forEach(tdMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(tdMark, function (score, mark) {\n                    var feature = featurize(yType, xType, true, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(tdMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(tdMark, function (score, mark) {\n                    var feature = featurize(yType, xType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n        });\n        // DxD\n        DISCRETE_OR_NONE.forEach(function (xType) {\n            DISCRETE_OR_NONE.forEach(function (yType) {\n                // has occlusion\n                var ddMark = {\n                    point: 0,\n                    rect: 0,\n                    text: -0.1,\n                    tick: -1,\n                    bar: -2,\n                    line: -2,\n                    area: -2,\n                    rule: -2.5\n                };\n                // No difference between has occlusion and no occlusion\n                util_1.forEach(ddMark, function (score, mark) {\n                    var feature = featurize(xType, yType, true, mark);\n                    SCORE[feature] = score;\n                });\n                util_1.forEach(ddMark, function (score, mark) {\n                    var feature = featurize(xType, yType, false, mark);\n                    SCORE[feature] = score;\n                });\n            });\n        });\n        return SCORE;\n    }\n    MarkScore.init = init;\n    function getScore(specM, schema, opt) {\n        var mark = specM.getMark();\n        if (mark === mark_1.Mark.CIRCLE || mark === mark_1.Mark.SQUARE) {\n            mark = mark_1.Mark.POINT;\n        }\n        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n        var xType = xEncQ ? type_1.getExtendedType(xEncQ) : type_1.NONE;\n        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n        var yType = yEncQ ? type_1.getExtendedType(yEncQ) : type_1.NONE;\n        var isOccluded = !specM.isAggregate(); // FIXME\n        var feature = xType + '_' + yType + '_' + isOccluded + '_' + mark;\n        var featureScore = effectiveness_1.getFeatureScore(MarkScore.MARK_SCORE, feature);\n        return [featureScore];\n    }\n    MarkScore.getScore = getScore;\n})(MarkScore = exports.MarkScore || (exports.MarkScore = {}));\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\nvar scale_1 = require('vega-lite/src/scale');\nvar type_1 = require('vega-lite/src/type');\nvar encoding_1 = require('../../query/encoding');\n/**\n * Finer grained data types that takes binning and timeUnit into account.\n */\n(function (ExtendedType) {\n    ExtendedType[ExtendedType[\"Q\"] = type_1.Type.QUANTITATIVE] = \"Q\";\n    ExtendedType[ExtendedType[\"BIN_Q\"] = 'bin_' + type_1.Type.QUANTITATIVE] = \"BIN_Q\";\n    ExtendedType[ExtendedType[\"T\"] = type_1.Type.TEMPORAL] = \"T\";\n    /**\n     * Time Unit Temporal Field with time scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_T\"] = 'timeUnit_time'] = \"TIMEUNIT_T\";\n    /**\n     * Time Unit Temporal Field with ordinal scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_O\"] = 'timeUnit_' + type_1.Type.ORDINAL] = \"TIMEUNIT_O\";\n    ExtendedType[ExtendedType[\"O\"] = type_1.Type.ORDINAL] = \"O\";\n    ExtendedType[ExtendedType[\"N\"] = type_1.Type.NOMINAL] = \"N\";\n    ExtendedType[ExtendedType[\"NONE\"] = '-'] = \"NONE\";\n})(exports.ExtendedType || (exports.ExtendedType = {}));\nvar ExtendedType = exports.ExtendedType;\nexports.Q = ExtendedType.Q;\nexports.BIN_Q = ExtendedType.BIN_Q;\nexports.T = ExtendedType.T;\nexports.TIMEUNIT_T = ExtendedType.TIMEUNIT_T;\nexports.TIMEUNIT_O = ExtendedType.TIMEUNIT_O;\nexports.O = ExtendedType.O;\nexports.N = ExtendedType.N;\nexports.NONE = ExtendedType.NONE;\nfunction getExtendedType(encQ) {\n    if (encQ.bin) {\n        return ExtendedType.BIN_Q;\n    }\n    else if (encQ.timeUnit) {\n        return encoding_1.scaleType(encQ) === scale_1.ScaleType.ORDINAL ? ExtendedType.TIMEUNIT_O : ExtendedType.TIMEUNIT_T;\n    }\n    return encQ.type;\n}\nexports.getExtendedType = getExtendedType;\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\nvar property_1 = require('../property');\nexports.name = 'fieldOrder';\nfunction score(specM, schema, opt) {\n    var fieldEnumSpecIndices = specM.enumSpecIndex.encodingIndicesByProperty[property_1.Property.FIELD];\n    if (!fieldEnumSpecIndices) {\n        return {\n            score: 0,\n            features: []\n        };\n    }\n    var encodings = specM.specQuery.encodings;\n    var numFields = schema.fieldSchemas.length;\n    var features = [];\n    var totalScore = 0, base = 1;\n    for (var i = fieldEnumSpecIndices.length - 1; i >= 0; i--) {\n        var index = fieldEnumSpecIndices[i];\n        var field = encodings[index].field;\n        var fieldEnumSpec = specM.enumSpecIndex.encodings[index].field;\n        var fieldIndex = schema.fieldSchema(field).index;\n        // reverse order field with lower index should get higher score and come first\n        var score_1 = -fieldIndex * base;\n        totalScore += score_1;\n        features.push({\n            score: score_1,\n            type: 'fieldOrder',\n            feature: \"field \" + fieldEnumSpec.name + \" is \" + field + \" (#\" + fieldIndex + \" in the schema)\"\n        });\n        base *= numFields;\n    }\n    return {\n        score: totalScore,\n        features: features\n    };\n}\nexports.score = score;\n//# sourceMappingURL=fieldorder.js.map",
    "\"use strict\";\nexports.effectiveness = require('./effectiveness/effectiveness');\nexports.aggregation = require('./aggregation');\nexports.fieldOrder = require('./fieldorder');\n/**\n * Registry for all encoding ranking functions\n */\nvar rankingRegistry = {};\n/**\n * Add an ordering function to the registry.\n */\nfunction register(name, keyFn) {\n    rankingRegistry[name] = keyFn;\n}\nexports.register = register;\nfunction get(name) {\n    return rankingRegistry[name];\n}\nexports.get = get;\nfunction rank(group, query, schema, level) {\n    if (!query.nest || level === query.nest.length) {\n        if (query.orderBy || query.chooseBy) {\n            group.items.sort(comparatorFactory(query.orderBy || query.chooseBy, schema, query.config));\n            if (query.chooseBy) {\n                if (group.items.length > 0) {\n                    // for chooseBy -- only keep the top-item\n                    group.items.splice(1);\n                }\n            }\n        }\n    }\n    else {\n        // sort lower-level nodes first because our ranking takes top-item in the subgroup\n        group.items.forEach(function (subgroup) {\n            rank(subgroup, query, schema, level + 1);\n        });\n        if (query.nest[level].orderGroupBy) {\n            group.items.sort(groupComparatorFactory(query.nest[level].orderGroupBy, schema, query.config));\n        }\n    }\n    return group;\n}\nexports.rank = rank;\nfunction comparatorFactory(name, schema, opt) {\n    return function (m1, m2) {\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.comparatorFactory = comparatorFactory;\nfunction groupComparatorFactory(name, schema, opt) {\n    return function (g1, g2) {\n        var m1 = g1.getTopSpecQueryModel();\n        var m2 = g2.getTopSpecQueryModel();\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.groupComparatorFactory = groupComparatorFactory;\nfunction getScoreDifference(name, m1, m2, schema, opt) {\n    for (var i = 0; i < name.length; i++) {\n        var scoreDifference = getScore(m2, name[i], schema, opt).score - getScore(m1, name[i], schema, opt).score;\n        if (scoreDifference !== 0) {\n            return scoreDifference;\n        }\n    }\n    return 0;\n}\nfunction getScore(model, rankingName, schema, opt) {\n    if (model.getRankingScore(rankingName) !== undefined) {\n        return model.getRankingScore(rankingName);\n    }\n    var fn = get(rankingName);\n    var score = fn(model, schema, opt);\n    model.setRankingScore(rankingName, score);\n    return score;\n}\nexports.getScore = getScore;\nexports.EFFECTIVENESS = 'effectiveness';\nregister(exports.EFFECTIVENESS, exports.effectiveness.default);\nregister(exports.aggregation.name, exports.aggregation.score);\nregister(exports.fieldOrder.name, exports.fieldOrder.score);\n//# sourceMappingURL=ranking.js.map",
    "\"use strict\";\nvar type_1 = require('vega-lite/src/type');\nvar bin_1 = require('vega-lite/src/bin');\nvar timeunit_1 = require('vega-lite/src/timeunit');\nvar stats_1 = require('datalib/src/stats');\nvar type_2 = require('datalib/src/import/type');\nvar dlBin = require('datalib/src/bins/bins');\nvar config_1 = require('./config');\nvar util_1 = require('./util');\nvar Schema = (function () {\n    function Schema(fieldSchemas) {\n        this._fieldSchemas = fieldSchemas;\n        this._fieldSchemaIndex = fieldSchemas.reduce(function (m, fieldSchema) {\n            m[fieldSchema.field] = fieldSchema;\n            return m;\n        }, {});\n    }\n    /**\n     * Build a Schema object.\n     *\n     * @param data - a set of raw data\n     * @return a Schema object\n     */\n    Schema.build = function (data, opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        // create profiles for each variable\n        var summaries = stats_1.summary(data);\n        var types = type_2.inferAll(data); // inferAll does stronger type inference than summary\n        var fieldSchemas = summaries.map(function (summary) {\n            var field = summary.field;\n            var primitiveType = types[field];\n            var distinct = summary.distinct;\n            var type;\n            if (primitiveType === PrimitiveType.NUMBER) {\n                type = type_1.Type.QUANTITATIVE;\n            }\n            else if (primitiveType === PrimitiveType.INTEGER) {\n                // use ordinal or nominal when cardinality of integer type is relatively low and the distinct values are less than an amount specified in options\n                if ((distinct < opt.numberNominalLimit) && (distinct / summary.count < opt.numberNominalProportion)) {\n                    type = type_1.Type.NOMINAL;\n                }\n                else {\n                    type = type_1.Type.QUANTITATIVE;\n                }\n            }\n            else if (primitiveType === PrimitiveType.DATE) {\n                type = type_1.Type.TEMPORAL;\n                // need to get correct min/max of date data because datalib's summary method does not\n                // calculate this correctly for date types.\n                summary.min = new Date(data[0][field]);\n                summary.max = new Date(data[0][field]);\n                for (var i = 0; i < data.length; i++) {\n                    var time = new Date(data[i][field]).getTime();\n                    if (time < summary.min.getTime()) {\n                        summary.min = new Date(time);\n                    }\n                    if (time > summary.max.getTime()) {\n                        summary.max = new Date(time);\n                    }\n                }\n            }\n            else {\n                type = type_1.Type.NOMINAL;\n            }\n            return {\n                field: field,\n                type: type,\n                primitiveType: primitiveType,\n                stats: summary,\n                timeStats: {},\n                binStats: {}\n            };\n        });\n        // order the fieldSchemas (sort them)\n        var order = {\n            'nominal': 0,\n            'ordinal': 1,\n            'temporal': 2,\n            'quantitative': 3\n        };\n        fieldSchemas.sort(function (a, b) {\n            // first order by type: nominal < temporal < quantitative < ordinal\n            if (order[a.type] < order[b.type]) {\n                return -1;\n            }\n            else if (order[a.type] > order[b.type]) {\n                return 1;\n            }\n            else {\n                // then order by field (alphabetically)\n                return a.field.localeCompare(b.field);\n            }\n        });\n        // Add index for sorting\n        fieldSchemas.forEach(function (fieldSchema, index) { return fieldSchema.index = index; });\n        // calculate preset bins for quantitative and temporal data\n        for (var _i = 0, fieldSchemas_1 = fieldSchemas; _i < fieldSchemas_1.length; _i++) {\n            var fieldSchema = fieldSchemas_1[_i];\n            if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\n                for (var _a = 0, _b = opt.maxBinsList; _a < _b.length; _a++) {\n                    var maxbins = _b[_a];\n                    fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n                }\n            }\n            else if (fieldSchema.type === type_1.Type.TEMPORAL) {\n                for (var _c = 0, _d = opt.timeUnits; _c < _d.length; _c++) {\n                    var unit = _d[_c];\n                    if (unit !== undefined) {\n                        fieldSchema.timeStats[unit] = timeSummary(unit, fieldSchema.stats);\n                    }\n                }\n            }\n        }\n        return new Schema(fieldSchemas);\n    };\n    /** @return a list of the field names. */\n    Schema.prototype.fields = function () {\n        return this._fieldSchemas.map(function (fieldSchema) { return fieldSchema.field; });\n    };\n    Object.defineProperty(Schema.prototype, \"fieldSchemas\", {\n        /** @return a list of FieldSchemas */\n        get: function () {\n            return this._fieldSchemas;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Schema.prototype.fieldSchema = function (field) {\n        return this._fieldSchemaIndex[field];\n    };\n    /**\n     * @return primitive type of the field if exist, otherwise return null\n     */\n    Schema.prototype.primitiveType = function (field) {\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].primitiveType : null;\n    };\n    /**\n     * @return type of measturement of the field if exist, otherwise return null\n     */\n    Schema.prototype.type = function (field) {\n        return this._fieldSchemaIndex[field] ? this._fieldSchemaIndex[field].type : null;\n    };\n    /** @return cardinality of the field associated with encQ, null if it doesn't exist.\n     *  @param augmentTimeUnitDomain - TimeUnit field domains will not be augmented if explicitly set to false.\n     */\n    Schema.prototype.cardinality = function (encQ, augmentTimeUnitDomain, excludeInvalid) {\n        if (augmentTimeUnitDomain === void 0) { augmentTimeUnitDomain = true; }\n        if (excludeInvalid === void 0) { excludeInvalid = false; }\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\n        if (encQ.aggregate || encQ.autoCount) {\n            return 1;\n        }\n        else if (encQ.bin) {\n            // encQ.bin will either be a boolean or a BinQuery\n            var bin;\n            if (typeof encQ.bin === 'boolean') {\n                // autoMaxBins defaults to 10 if channel is EnumSpec\n                bin = {\n                    maxbins: bin_1.autoMaxBins(encQ.channel)\n                };\n            }\n            else {\n                bin = encQ.bin;\n            }\n            var maxbins = bin.maxbins;\n            if (!fieldSchema.binStats[maxbins]) {\n                // need to calculate\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n            }\n            // don't need to worry about excludeInvalid here because invalid values don't affect linearly binned field's cardinality\n            return fieldSchema.binStats[maxbins].distinct;\n        }\n        else if (encQ.timeUnit) {\n            if (augmentTimeUnitDomain) {\n                switch (encQ.timeUnit) {\n                    // TODO: this should not always be the case once Vega-Lite supports turning off domain augmenting (VL issue #1385)\n                    case timeunit_1.TimeUnit.SECONDS: return 60;\n                    case timeunit_1.TimeUnit.MINUTES: return 60;\n                    case timeunit_1.TimeUnit.HOURS: return 24;\n                    case timeunit_1.TimeUnit.DAY: return 7;\n                    case timeunit_1.TimeUnit.DATE: return 31;\n                    case timeunit_1.TimeUnit.MONTH: return 12;\n                    case timeunit_1.TimeUnit.QUARTER: return 4;\n                    case timeunit_1.TimeUnit.MILLISECONDS: return 1000;\n                }\n            }\n            var unit = encQ.timeUnit;\n            var timeStats = fieldSchema.timeStats;\n            // if the cardinality for the timeUnit is not cached, calculate it\n            if (!timeStats[unit]) {\n                timeStats[unit] = timeSummary(encQ.timeUnit, fieldSchema.stats);\n            }\n            if (excludeInvalid) {\n                return timeStats[unit].distinct - invalidCount(timeStats[unit].unique, ['Invalid Date', null]);\n            }\n            else {\n                return timeStats[unit].distinct;\n            }\n        }\n        else {\n            if (fieldSchema) {\n                if (excludeInvalid) {\n                    return fieldSchema.stats.distinct - invalidCount(fieldSchema.stats.unique, [NaN, null]);\n                }\n                else {\n                    return fieldSchema.stats.distinct;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Given an EncodingQuery with a timeUnit, returns true if the date field\n     * has multiple distinct values for all parts of the timeUnit. Returns undefined\n     * if the timeUnit is undefined.\n     * i.e.\n     * ('yearmonth', [Jan 1 2000, Feb 2 2000] returns false)\n     * ('yearmonth', [Jan 1 2000, Feb 2 2001] returns true)\n     */\n    Schema.prototype.timeUnitHasVariation = function (encQ) {\n        if (!encQ.timeUnit) {\n            return;\n        }\n        // if there is no variation in `date`, there should not be variation in `day`\n        if (encQ.timeUnit === timeunit_1.TimeUnit.DAY) {\n            var dateEncQ = util_1.extend({}, encQ, { timeUnit: timeunit_1.TimeUnit.DATE });\n            if (this.cardinality(dateEncQ, false, true) <= 1) {\n                return false;\n            }\n        }\n        var fullTimeUnit = encQ.timeUnit;\n        for (var _i = 0, SINGLE_TIMEUNITS_1 = timeunit_1.SINGLE_TIMEUNITS; _i < SINGLE_TIMEUNITS_1.length; _i++) {\n            var singleUnit = SINGLE_TIMEUNITS_1[_i];\n            if (timeunit_1.containsTimeUnit(fullTimeUnit, singleUnit)) {\n                encQ.timeUnit = singleUnit;\n                if (this.cardinality(encQ, false, true) <= 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    Schema.prototype.domain = function (encQ) {\n        // TODO: differentiate for field with bin / timeUnit\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\n        var domain = util_1.keys(fieldSchema.stats.unique);\n        if (fieldSchema.type === type_1.Type.QUANTITATIVE) {\n            // return [min, max], coerced into number types\n            return [+fieldSchema.stats.min, +fieldSchema.stats.max];\n        }\n        else if (fieldSchema.primitiveType === PrimitiveType.DATE) {\n            // return [min, max] dates\n            return [fieldSchema.stats.min, fieldSchema.stats.max];\n        }\n        else if (fieldSchema.primitiveType === PrimitiveType.INTEGER ||\n            fieldSchema.primitiveType === PrimitiveType.NUMBER) {\n            // coerce non-quantitative numerical data into number type\n            domain = domain.map(function (x) { return +x; });\n            return domain.sort(util_1.cmp);\n        }\n        return domain.map(function (x) {\n            // Convert 'null' to null as it is encoded similarly in datalib.\n            // This is wrong when it is a string 'null' but that rarely happens.\n            return x === 'null' ? null : x;\n        }).sort(util_1.cmp);\n    };\n    /**\n     * @return a Summary corresponding to the field of the given EncodingQuery\n     */\n    Schema.prototype.stats = function (encQ) {\n        // TODO: differentiate for field with bin / timeUnit vs without\n        var fieldSchema = this._fieldSchemaIndex[encQ.field];\n        return fieldSchema ? fieldSchema.stats : null;\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n/**\n * @return a summary of the binning scheme determined from the given max number of bins\n */\nfunction binSummary(maxbins, summary) {\n    var bin = dlBin({\n        min: summary.min,\n        max: summary.max,\n        maxbins: maxbins\n    });\n    // start with summary, pre-binning\n    var result = util_1.extend({}, summary);\n    result.unique = binUnique(bin, summary.unique);\n    result.distinct = (bin.stop - bin.start) / bin.step;\n    result.min = bin.start;\n    result.max = bin.stop;\n    return result;\n}\n/** @return a modified version of the passed summary with unique and distinct set according to the timeunit.\n *  Maps 'null' (string) keys to the null value and invalid dates to 'Invalid Date' in the unique dictionary.\n */\nfunction timeSummary(timeunit, summary) {\n    var result = util_1.extend({}, summary);\n    var unique = {};\n    util_1.keys(summary.unique).forEach(function (dateString) {\n        // don't convert null value because the Date constructor will actually convert it to a date\n        var date = (dateString === 'null') ? null : new Date(dateString);\n        // at this point, `date` is either the null value, a valid Date object, or \"Invalid Date\" which is a Date\n        var key;\n        if (date === null) {\n            key = null;\n        }\n        else if (isNaN(date.getTime())) {\n            key = 'Invalid Date';\n        }\n        else {\n            key = ((timeunit === timeunit_1.TimeUnit.DAY) ? date.getDay() : timeunit_1.convert(timeunit, date)).toString();\n        }\n        unique[key] = (unique[key] || 0) + summary.unique[dateString];\n    });\n    result.unique = unique;\n    result.distinct = util_1.keys(unique).length;\n    return result;\n}\n/**\n * @return a new unique object based off of the old unique count and a binning scheme\n */\nfunction binUnique(bin, oldUnique) {\n    var newUnique = {};\n    for (var value in oldUnique) {\n        var bucket = void 0;\n        if (value === null) {\n            bucket = null;\n        }\n        else if (isNaN(Number(value))) {\n            bucket = NaN;\n        }\n        else {\n            bucket = bin.value(Number(value));\n        }\n        newUnique[bucket] = (newUnique[bucket] || 0) + oldUnique[value];\n    }\n    return newUnique;\n}\n/** @return the number of items in list that occur as keys of unique */\nfunction invalidCount(unique, list) {\n    return list.reduce(function (prev, cur) {\n        return unique[cur] ? prev + 1 : prev;\n    }, 0);\n}\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"STRING\"] = 'string'] = \"STRING\";\n    PrimitiveType[PrimitiveType[\"NUMBER\"] = 'number'] = \"NUMBER\";\n    PrimitiveType[PrimitiveType[\"INTEGER\"] = 'integer'] = \"INTEGER\";\n    PrimitiveType[PrimitiveType[\"BOOLEAN\"] = 'boolean'] = \"BOOLEAN\";\n    PrimitiveType[PrimitiveType[\"DATE\"] = 'date'] = \"DATE\";\n})(exports.PrimitiveType || (exports.PrimitiveType = {}));\nvar PrimitiveType = exports.PrimitiveType;\n//# sourceMappingURL=schema.js.map",
    "\"use strict\";\nvar axis_1 = require('vega-lite/src/axis');\nvar channel_1 = require('vega-lite/src/channel');\nvar scale_1 = require('vega-lite/src/scale');\nvar type_1 = require('vega-lite/src/type');\nvar encoding_1 = require('./query/encoding');\nvar util_1 = require('./util');\nfunction stylize(answerSet, schema, opt) {\n    var encQIndex = {};\n    answerSet = answerSet.map(function (specM) {\n        if (opt.smallBandSizeForHighCardinalityOrFacet) {\n            specM = smallBandSizeForHighCardinalityOrFacet(specM, schema, encQIndex, opt);\n        }\n        if (opt.nominalColorScaleForHighCardinality) {\n            specM = nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt);\n        }\n        if (opt.xAxisOnTopForHighYCardinalityWithoutColumn) {\n            specM = xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt);\n        }\n        return specM;\n    });\n    return answerSet;\n}\nexports.stylize = stylize;\nfunction smallBandSizeForHighCardinalityOrFacet(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.ROW, channel_1.Channel.Y, channel_1.Channel.COLUMN, channel_1.Channel.X].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    var yEncQ = encQIndex[channel_1.Channel.Y];\n    if (yEncQ !== undefined) {\n        if (encQIndex[channel_1.Channel.ROW] ||\n            schema.cardinality(yEncQ) > opt.smallBandSizeForHighCardinalityOrFacet.maxCardinality) {\n            // We check for undefined rather than\n            // yEncQ.scale = yEncQ.scale || {} to cover the case where\n            // yEncQ.scale has been set to false/null.\n            // This prevents us from incorrectly overriding scale and\n            // assigning a bandSize when scale is set to false.\n            if (yEncQ.scale === undefined) {\n                yEncQ.scale = {};\n            }\n            // We do not want to assign a bandSize if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            if (yEncQ.scale && util_1.contains([scale_1.ScaleType.ORDINAL, undefined], encoding_1.scaleType(yEncQ))) {\n                if (!yEncQ.scale.bandSize) {\n                    yEncQ.scale.bandSize = 12;\n                }\n            }\n        }\n    }\n    var xEncQ = encQIndex[channel_1.Channel.X];\n    if (xEncQ !== undefined) {\n        if (encQIndex[channel_1.Channel.COLUMN] ||\n            schema.cardinality(xEncQ) > opt.smallBandSizeForHighCardinalityOrFacet.maxCardinality) {\n            // Just like y, we don't want to do this if scale is null/false\n            if (xEncQ.scale === undefined) {\n                xEncQ.scale = {};\n            }\n            // We do not want to assign a bandSize if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            if (xEncQ.scale && util_1.contains([scale_1.ScaleType.ORDINAL, undefined], encoding_1.scaleType(xEncQ))) {\n                if (!xEncQ.scale.bandSize) {\n                    xEncQ.scale.bandSize = 12;\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.smallBandSizeForHighCardinalityOrFacet = smallBandSizeForHighCardinalityOrFacet;\nfunction nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt) {\n    encQIndex[channel_1.Channel.COLOR] = specM.getEncodingQueryByChannel(channel_1.Channel.COLOR);\n    var colorEncQ = encQIndex[channel_1.Channel.COLOR];\n    if ((colorEncQ !== undefined) && (colorEncQ.type === type_1.Type.NOMINAL) &&\n        (schema.cardinality(colorEncQ) > opt.nominalColorScaleForHighCardinality.maxCardinality)) {\n        if (colorEncQ.scale === undefined) {\n            colorEncQ.scale = {};\n        }\n        if (colorEncQ.scale) {\n            if (!colorEncQ.scale.range) {\n                colorEncQ.scale.range = opt.nominalColorScaleForHighCardinality.palette;\n            }\n        }\n    }\n    return specM;\n}\nexports.nominalColorScaleForHighCardinality = nominalColorScaleForHighCardinality;\nfunction xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.COLUMN, channel_1.Channel.X, channel_1.Channel.Y].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    if (encQIndex[channel_1.Channel.COLUMN] === undefined) {\n        var xEncQ = encQIndex[channel_1.Channel.X];\n        var yEncQ = encQIndex[channel_1.Channel.Y];\n        if (yEncQ !== undefined && yEncQ.field && encoding_1.scaleType(yEncQ) === scale_1.ScaleType.ORDINAL) {\n            if (xEncQ !== undefined) {\n                if (schema.cardinality(yEncQ) > opt.xAxisOnTopForHighYCardinalityWithoutColumn.maxCardinality) {\n                    if (xEncQ.axis === undefined) {\n                        xEncQ.axis = {};\n                    }\n                    if (xEncQ.axis && !xEncQ.axis.orient) {\n                        xEncQ.axis.orient = axis_1.AxisOrient.TOP;\n                    }\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.xAxisOnTopForHighYCardinalityWithoutColumn = xAxisOnTopForHighYCardinalityWithoutColumn;\n//# sourceMappingURL=stylize.js.map",
    "\"use strict\";\nvar util_1 = require('datalib/src/util');\nvar util_2 = require('datalib/src/util');\nexports.cmp = util_2.cmp;\nexports.keys = util_2.keys;\nexports.duplicate = util_2.duplicate;\nexports.extend = util_2.extend;\nexports.isObject = util_2.isObject;\nexports.isArray = util_2.isArray;\nfunction contains(array, item) {\n    return array.indexOf(item) !== -1;\n}\nexports.contains = contains;\n;\nfunction every(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\n;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            f.call(thisArg, obj[k], k, obj);\n        }\n    }\n}\nexports.forEach = forEach;\n;\nfunction some(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n;\nfunction nestedMap(array, f) {\n    return array.map(function (a) {\n        if (util_1.isArray(a)) {\n            return nestedMap(a, f);\n        }\n        return f(a);\n    });\n}\nexports.nestedMap = nestedMap;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\n//# sourceMappingURL=util.js.map",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a, b) {\n    var i, n, f, c;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i];\n      c = u.cmp(f(a), f(b));\n      if (c) return c * sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  return (a < b || a == null) && b != null ? -1 :\n    (a > b || b == null) && a != null ? 1 :\n    ((b = b instanceof Date ? +b : b),\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\n    b !== b && a === a ? 1 : 0;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\"use strict\";\n(function (AggregateOp) {\n    AggregateOp[AggregateOp[\"VALUES\"] = 'values'] = \"VALUES\";\n    AggregateOp[AggregateOp[\"COUNT\"] = 'count'] = \"COUNT\";\n    AggregateOp[AggregateOp[\"VALID\"] = 'valid'] = \"VALID\";\n    AggregateOp[AggregateOp[\"MISSING\"] = 'missing'] = \"MISSING\";\n    AggregateOp[AggregateOp[\"DISTINCT\"] = 'distinct'] = \"DISTINCT\";\n    AggregateOp[AggregateOp[\"SUM\"] = 'sum'] = \"SUM\";\n    AggregateOp[AggregateOp[\"MEAN\"] = 'mean'] = \"MEAN\";\n    AggregateOp[AggregateOp[\"AVERAGE\"] = 'average'] = \"AVERAGE\";\n    AggregateOp[AggregateOp[\"VARIANCE\"] = 'variance'] = \"VARIANCE\";\n    AggregateOp[AggregateOp[\"VARIANCEP\"] = 'variancep'] = \"VARIANCEP\";\n    AggregateOp[AggregateOp[\"STDEV\"] = 'stdev'] = \"STDEV\";\n    AggregateOp[AggregateOp[\"STDEVP\"] = 'stdevp'] = \"STDEVP\";\n    AggregateOp[AggregateOp[\"MEDIAN\"] = 'median'] = \"MEDIAN\";\n    AggregateOp[AggregateOp[\"Q1\"] = 'q1'] = \"Q1\";\n    AggregateOp[AggregateOp[\"Q3\"] = 'q3'] = \"Q3\";\n    AggregateOp[AggregateOp[\"MODESKEW\"] = 'modeskew'] = \"MODESKEW\";\n    AggregateOp[AggregateOp[\"MIN\"] = 'min'] = \"MIN\";\n    AggregateOp[AggregateOp[\"MAX\"] = 'max'] = \"MAX\";\n    AggregateOp[AggregateOp[\"ARGMIN\"] = 'argmin'] = \"ARGMIN\";\n    AggregateOp[AggregateOp[\"ARGMAX\"] = 'argmax'] = \"ARGMAX\";\n})(exports.AggregateOp || (exports.AggregateOp = {}));\nvar AggregateOp = exports.AggregateOp;\nexports.AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexports.SUM_OPS = [\n    AggregateOp.COUNT,\n    AggregateOp.SUM,\n    AggregateOp.DISTINCT\n];\nexports.SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n//# sourceMappingURL=aggregate.js.map",
    "\"use strict\";\n(function (AxisOrient) {\n    AxisOrient[AxisOrient[\"TOP\"] = 'top'] = \"TOP\";\n    AxisOrient[AxisOrient[\"RIGHT\"] = 'right'] = \"RIGHT\";\n    AxisOrient[AxisOrient[\"LEFT\"] = 'left'] = \"LEFT\";\n    AxisOrient[AxisOrient[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\n})(exports.AxisOrient || (exports.AxisOrient = {}));\nvar AxisOrient = exports.AxisOrient;\n// TODO: add comment for properties that we rely on Vega's default to produce\n// more concise Vega output.\nexports.defaultAxisConfig = {\n    offset: undefined,\n    grid: undefined,\n    labels: true,\n    labelMaxLength: 25,\n    tickSize: undefined,\n    characterWidth: 6\n};\nexports.defaultFacetAxisConfig = {\n    axisWidth: 0,\n    labels: true,\n    grid: false,\n    tickSize: 0\n};\n//# sourceMappingURL=axis.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nfunction autoMaxBins(channel) {\n    switch (channel) {\n        case channel_1.ROW:\n        case channel_1.COLUMN:\n        case channel_1.SIZE:\n        // Facets and Size shouldn't have too many bins\n        // We choose 6 like shape to simplify the rule\n        case channel_1.SHAPE:\n            return 6; // Vega's \"shape\" has 6 distinct values\n        default:\n            return 10;\n    }\n}\nexports.autoMaxBins = autoMaxBins;\n//# sourceMappingURL=bin.js.map",
    "/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\"use strict\";\nvar util_1 = require('./util');\n(function (Channel) {\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\n    Channel[Channel[\"X2\"] = 'x2'] = \"X2\";\n    Channel[Channel[\"Y2\"] = 'y2'] = \"Y2\";\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\n    Channel[Channel[\"LABEL\"] = 'label'] = \"LABEL\";\n    Channel[Channel[\"PATH\"] = 'path'] = \"PATH\";\n    Channel[Channel[\"ORDER\"] = 'order'] = \"ORDER\";\n    Channel[Channel[\"OPACITY\"] = 'opacity'] = \"OPACITY\";\n})(exports.Channel || (exports.Channel = {}));\nvar Channel = exports.Channel;\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.LABEL = Channel.LABEL;\nexports.PATH = Channel.PATH;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.PATH, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.LABEL];\nexports.UNIT_CHANNELS = util_1.without(exports.CHANNELS, [exports.ROW, exports.COLUMN]);\nexports.UNIT_SCALE_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.PATH, exports.ORDER, exports.DETAIL, exports.TEXT, exports.LABEL, exports.X2, exports.Y2]);\nexports.NONSPATIAL_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\nexports.NONSPATIAL_SCALE_CHANNELS = util_1.without(exports.UNIT_SCALE_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\n/** Channels that can serve as groupings for stacked charts. */\nexports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];\n;\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nfunction supportMark(channel, mark) {\n    return !!getSupportedMark(channel)[mark];\n}\nexports.supportMark = supportMark;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.ORDER:\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, line: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n            return {\n                rule: true, bar: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n        case exports.PATH:\n            return { line: true };\n    }\n    return {};\n}\nexports.getSupportedMark = getSupportedMark;\n;\n/**\n * Return whether a channel supports dimension / measure role\n * @param  channel\n * @return A dictionary mapping role to boolean values.\n */\nfunction getSupportedRole(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.OPACITY:\n        case exports.LABEL:\n        case exports.DETAIL:\n            return {\n                measure: true,\n                dimension: true\n            };\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n            return {\n                measure: false,\n                dimension: true\n            };\n        case exports.X2:\n        case exports.Y2:\n        case exports.SIZE:\n        case exports.TEXT:\n            return {\n                measure: true,\n                dimension: false\n            };\n        case exports.PATH:\n            return {\n                measure: false,\n                dimension: true\n            };\n    }\n    throw new Error('Invalid encoding channel' + channel);\n}\nexports.getSupportedRole = getSupportedRole;\nfunction hasScale(channel) {\n    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);\n}\nexports.hasScale = hasScale;\n//# sourceMappingURL=channel.js.map",
    "// DateTime definition object\n\"use strict\";\nvar util_1 = require('./util');\nfunction isDateTime(o) {\n    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\nexports.isDateTime = isDateTime;\nexports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });\nexports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });\nfunction normalizeQuarter(q) {\n    if (util_1.isNumber(q)) {\n        // We accept 1-based quarter, so need to readjust to 0-based quarter\n        return (q - 1) + '';\n    }\n    else {\n        // Simply an expression string, but normalize should not be called in this case.\n        console.warn('Potentially invalid quarter', q);\n        return q;\n    }\n}\nfunction normalizeMonth(m) {\n    if (util_1.isNumber(m)) {\n        // We accept 1-based month, so need to readjust to 0-based month\n        return (m - 1) + '';\n    }\n    else {\n        var lowerM = m.toLowerCase();\n        var monthIndex = exports.MONTHS.indexOf(lowerM);\n        if (monthIndex !== -1) {\n            return monthIndex + ''; // 0 for january, ...\n        }\n        var shortM = lowerM.substr(0, 3);\n        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);\n        if (shortMonthIndex !== -1) {\n            return shortMonthIndex + '';\n        }\n        // Simply an expression string, but normalize should not be called in this case.\n        console.warn('Potentially invalid month', m);\n        return m;\n    }\n}\nfunction normalizeDay(d) {\n    if (util_1.isNumber(d)) {\n        // mod so that this can be both 0-based where 0 = sunday\n        // and 1-based where 7=sunday\n        return (d % 7) + '';\n    }\n    else {\n        var lowerD = d.toLowerCase();\n        var dayIndex = exports.DAYS.indexOf(lowerD);\n        if (dayIndex !== -1) {\n            return dayIndex + ''; // 0 for january, ...\n        }\n        var shortD = lowerD.substr(0, 3);\n        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);\n        if (shortDayIndex !== -1) {\n            return shortDayIndex + '';\n        }\n        // Simply an expression string, but normalize should not be called in this case.\n        console.warn('Potentially invalid day', d);\n        return d;\n    }\n}\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nfunction dateTimeExpr(d, normalize) {\n    if (normalize === void 0) { normalize = false; }\n    var units = [];\n    if (normalize && d.day !== undefined) {\n        for (var _i = 0, _a = ['year', 'quarter', 'month', 'date']; _i < _a.length; _i++) {\n            var unit = _a[_i];\n            if (d[unit] !== undefined) {\n                console.warn('Dropping day from datetime', JSON.stringify(d), 'as day cannot be combined with', unit);\n                d = util_1.duplicate(d);\n                delete d.day;\n                break;\n            }\n        }\n    }\n    if (d.year !== undefined) {\n        units.push(d.year);\n    }\n    else if (d.day !== undefined) {\n        // Set year to 2006 for working with day since January 1 2006 is a Sunday\n        units.push(2006);\n    }\n    else {\n        units.push(0);\n    }\n    if (d.month !== undefined) {\n        var month = normalize ? normalizeMonth(d.month) : d.month;\n        units.push(month);\n    }\n    else if (d.quarter !== undefined) {\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n        units.push(quarter + '*3');\n    }\n    else {\n        units.push(0); // months start at zero in JS\n    }\n    if (d.date !== undefined) {\n        units.push(d.date);\n    }\n    else if (d.day !== undefined) {\n        // HACK: Day only works as a standalone unit\n        // This is only correct because we always set year to 2006 for day\n        var day = normalize ? normalizeDay(d.day) : d.day;\n        units.push(day + '+1');\n    }\n    else {\n        units.push(1); // Date starts at 1 in JS\n    }\n    // Note: can't use TimeUnit enum here as importing it will create\n    // circular dependency problem!\n    for (var _b = 0, _c = ['hours', 'minutes', 'seconds', 'milliseconds']; _b < _c.length; _b++) {\n        var timeUnit = _c[_b];\n        if (d[timeUnit] !== undefined) {\n            units.push(d[timeUnit]);\n        }\n        else {\n            units.push(0);\n        }\n    }\n    return 'datetime(' + units.join(', ') + ')';\n}\nexports.dateTimeExpr = dateTimeExpr;\n//# sourceMappingURL=datetime.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar util_1 = require('./util');\nfunction countRetinal(encoding) {\n    var count = 0;\n    if (encoding.color) {\n        count++;\n    }\n    if (encoding.opacity) {\n        count++;\n    }\n    if (encoding.size) {\n        count++;\n    }\n    if (encoding.shape) {\n        count++;\n    }\n    return count;\n}\nexports.countRetinal = countRetinal;\nfunction channels(encoding) {\n    return channel_1.CHANNELS.filter(function (channel) {\n        return has(encoding, channel);\n    });\n}\nexports.channels = channels;\n// TOD: rename this to hasChannelField and only use we really want it.\nfunction has(encoding, channel) {\n    var channelEncoding = encoding && encoding[channel];\n    return channelEncoding && (channelEncoding.field !== undefined ||\n        // TODO: check that we have field in the array\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\n}\nexports.has = has;\nfunction isAggregate(encoding) {\n    return util_1.some(channel_1.CHANNELS, function (channel) {\n        if (has(encoding, channel) && encoding[channel].aggregate) {\n            return true;\n        }\n        return false;\n    });\n}\nexports.isAggregate = isAggregate;\nfunction isRanged(encoding) {\n    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\nexports.isRanged = isRanged;\nfunction fieldDefs(encoding) {\n    var arr = [];\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    arr.push(fieldDef);\n                });\n            }\n            else {\n                arr.push(encoding[channel]);\n            }\n        }\n    });\n    return arr;\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction forEach(encoding, f, thisArg) {\n    channelMappingForEach(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.forEach = forEach;\nfunction channelMappingForEach(channels, mapping, f, thisArg) {\n    var i = 0;\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    f.call(thisArg, fieldDef, channel, i++);\n                });\n            }\n            else {\n                f.call(thisArg, mapping[channel], channel, i++);\n            }\n        }\n    });\n}\nexports.channelMappingForEach = channelMappingForEach;\nfunction map(encoding, f, thisArg) {\n    return channelMappingMap(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.map = map;\nfunction channelMappingMap(channels, mapping, f, thisArg) {\n    var arr = [];\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    arr.push(f.call(thisArg, fieldDef, channel));\n                });\n            }\n            else {\n                arr.push(f.call(thisArg, mapping[channel], channel));\n            }\n        }\n    });\n    return arr;\n}\nexports.channelMappingMap = channelMappingMap;\nfunction reduce(encoding, f, init, thisArg) {\n    return channelMappingReduce(channel_1.CHANNELS, encoding, f, init, thisArg);\n}\nexports.reduce = reduce;\nfunction channelMappingReduce(channels, mapping, f, init, thisArg) {\n    var r = init;\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    r = f.call(thisArg, r, fieldDef, channel);\n                });\n            }\n            else {\n                r = f.call(thisArg, r, mapping[channel], channel);\n            }\n        }\n    });\n    return r;\n}\nexports.channelMappingReduce = channelMappingReduce;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\n(function (Mark) {\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\n    Mark[Mark[\"RULE\"] = 'rule'] = \"RULE\";\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\n    Mark[Mark[\"ERRORBAR\"] = 'errorBar'] = \"ERRORBAR\";\n})(exports.Mark || (exports.Mark = {}));\nvar Mark = exports.Mark;\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.RULE = Mark.RULE;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\nexports.ERRORBAR = Mark.ERRORBAR;\nexports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RULE, exports.CIRCLE, exports.SQUARE];\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\n(function (ScaleType) {\n    ScaleType[ScaleType[\"LINEAR\"] = 'linear'] = \"LINEAR\";\n    ScaleType[ScaleType[\"LOG\"] = 'log'] = \"LOG\";\n    ScaleType[ScaleType[\"POW\"] = 'pow'] = \"POW\";\n    ScaleType[ScaleType[\"SQRT\"] = 'sqrt'] = \"SQRT\";\n    ScaleType[ScaleType[\"QUANTILE\"] = 'quantile'] = \"QUANTILE\";\n    ScaleType[ScaleType[\"QUANTIZE\"] = 'quantize'] = \"QUANTIZE\";\n    ScaleType[ScaleType[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    ScaleType[ScaleType[\"TIME\"] = 'time'] = \"TIME\";\n    ScaleType[ScaleType[\"UTC\"] = 'utc'] = \"UTC\";\n})(exports.ScaleType || (exports.ScaleType = {}));\nvar ScaleType = exports.ScaleType;\n(function (NiceTime) {\n    NiceTime[NiceTime[\"SECOND\"] = 'second'] = \"SECOND\";\n    NiceTime[NiceTime[\"MINUTE\"] = 'minute'] = \"MINUTE\";\n    NiceTime[NiceTime[\"HOUR\"] = 'hour'] = \"HOUR\";\n    NiceTime[NiceTime[\"DAY\"] = 'day'] = \"DAY\";\n    NiceTime[NiceTime[\"WEEK\"] = 'week'] = \"WEEK\";\n    NiceTime[NiceTime[\"MONTH\"] = 'month'] = \"MONTH\";\n    NiceTime[NiceTime[\"YEAR\"] = 'year'] = \"YEAR\";\n})(exports.NiceTime || (exports.NiceTime = {}));\nvar NiceTime = exports.NiceTime;\n(function (BandSize) {\n    BandSize[BandSize[\"FIT\"] = 'fit'] = \"FIT\";\n})(exports.BandSize || (exports.BandSize = {}));\nvar BandSize = exports.BandSize;\nexports.BANDSIZE_FIT = BandSize.FIT;\nexports.defaultScaleConfig = {\n    round: true,\n    textBandWidth: 90,\n    bandSize: 21,\n    padding: 0.1,\n    useRawDomain: false,\n    opacity: [0.3, 0.8],\n    nominalColorRange: 'category10',\n    sequentialColorRange: ['#AFC6A3', '#09622A'],\n    shapeRange: 'shapes',\n    fontSizeRange: [8, 40],\n    ruleSizeRange: [1, 5],\n    tickSizeRange: [1, 20]\n};\nexports.defaultFacetScaleConfig = {\n    round: true,\n    padding: 16\n};\n//# sourceMappingURL=scale.js.map",
    "\"use strict\";\n(function (SortOrder) {\n    SortOrder[SortOrder[\"ASCENDING\"] = 'ascending'] = \"ASCENDING\";\n    SortOrder[SortOrder[\"DESCENDING\"] = 'descending'] = \"DESCENDING\";\n    SortOrder[SortOrder[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.SortOrder || (exports.SortOrder = {}));\nvar SortOrder = exports.SortOrder;\nfunction isSortField(sort) {\n    return !!sort && !!sort['field'] && !!sort['op'];\n}\nexports.isSortField = isSortField;\n//# sourceMappingURL=sort.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar encoding_1 = require('./encoding');\nvar mark_1 = require('./mark');\nvar util_1 = require('./util');\n(function (StackOffset) {\n    StackOffset[StackOffset[\"ZERO\"] = 'zero'] = \"ZERO\";\n    StackOffset[StackOffset[\"CENTER\"] = 'center'] = \"CENTER\";\n    StackOffset[StackOffset[\"NORMALIZE\"] = 'normalize'] = \"NORMALIZE\";\n    StackOffset[StackOffset[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.StackOffset || (exports.StackOffset = {}));\nvar StackOffset = exports.StackOffset;\nfunction stack(mark, encoding, config) {\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains([StackOffset.NONE, null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!encoding_1.isAggregate(encoding)) {\n        return null;\n    }\n    // Should have grouping level of detail\n    var stackByChannels = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {\n        if (encoding_1.has(encoding, channel) && !encoding[channel].aggregate) {\n            sc.push(channel);\n        }\n        return sc;\n    }, []);\n    if (stackByChannels.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var hasXField = encoding_1.has(encoding, channel_1.X);\n    var hasYField = encoding_1.has(encoding, channel_1.Y);\n    var xIsAggregate = hasXField && !!encoding.x.aggregate;\n    var yIsAggregate = hasYField && !!encoding.y.aggregate;\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            stackByChannels: stackByChannels,\n            offset: stacked || StackOffset.ZERO\n        };\n    }\n    return null;\n}\nexports.stack = stack;\n//# sourceMappingURL=stack.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar datetime_1 = require('./datetime');\nvar scale_1 = require('./scale');\nvar util_1 = require('./util');\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"YEAR\"] = 'year'] = \"YEAR\";\n    TimeUnit[TimeUnit[\"MONTH\"] = 'month'] = \"MONTH\";\n    TimeUnit[TimeUnit[\"DAY\"] = 'day'] = \"DAY\";\n    TimeUnit[TimeUnit[\"DATE\"] = 'date'] = \"DATE\";\n    TimeUnit[TimeUnit[\"HOURS\"] = 'hours'] = \"HOURS\";\n    TimeUnit[TimeUnit[\"MINUTES\"] = 'minutes'] = \"MINUTES\";\n    TimeUnit[TimeUnit[\"SECONDS\"] = 'seconds'] = \"SECONDS\";\n    TimeUnit[TimeUnit[\"MILLISECONDS\"] = 'milliseconds'] = \"MILLISECONDS\";\n    TimeUnit[TimeUnit[\"YEARMONTH\"] = 'yearmonth'] = \"YEARMONTH\";\n    // Note: don't add MONTH DATE because it will be incorrect\n    // since days on a leap year will be shifted by one if\n    // we only add\n    TimeUnit[TimeUnit[\"YEARMONTHDATE\"] = 'yearmonthdate'] = \"YEARMONTHDATE\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURS\"] = 'yearmonthdatehours'] = \"YEARMONTHDATEHOURS\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURSMINUTES\"] = 'yearmonthdatehoursminutes'] = \"YEARMONTHDATEHOURSMINUTES\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATEHOURSMINUTESSECONDS\"] = 'yearmonthdatehoursminutesseconds'] = \"YEARMONTHDATEHOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"HOURSMINUTES\"] = 'hoursminutes'] = \"HOURSMINUTES\";\n    TimeUnit[TimeUnit[\"HOURSMINUTESSECONDS\"] = 'hoursminutesseconds'] = \"HOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"MINUTESSECONDS\"] = 'minutesseconds'] = \"MINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"SECONDSMILLISECONDS\"] = 'secondsmilliseconds'] = \"SECONDSMILLISECONDS\";\n    TimeUnit[TimeUnit[\"QUARTER\"] = 'quarter'] = \"QUARTER\";\n    TimeUnit[TimeUnit[\"YEARQUARTER\"] = 'yearquarter'] = \"YEARQUARTER\";\n    TimeUnit[TimeUnit[\"QUARTERMONTH\"] = 'quartermonth'] = \"QUARTERMONTH\";\n    TimeUnit[TimeUnit[\"YEARQUARTERMONTH\"] = 'yearquartermonth'] = \"YEARQUARTERMONTH\";\n})(exports.TimeUnit || (exports.TimeUnit = {}));\nvar TimeUnit = exports.TimeUnit;\n/** Time Unit that only corresponds to only one part of Date objects. */\nexports.SINGLE_TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.QUARTER,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n];\nvar SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {\n    d[timeUnit] = true;\n    return d;\n}, {});\nfunction isSingleTimeUnit(timeUnit) {\n    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isSingleTimeUnit = isSingleTimeUnit;\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nfunction convert(unit, date) {\n    var result = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {\n        if (containsTimeUnit(unit, singleUnit)) {\n            switch (singleUnit) {\n                case TimeUnit.DAY:\n                    throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n                case TimeUnit.YEAR:\n                    result.setFullYear(date.getFullYear());\n                    break;\n                case TimeUnit.QUARTER:\n                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n                    break;\n                case TimeUnit.MONTH:\n                    result.setMonth(date.getMonth());\n                    break;\n                case TimeUnit.DATE:\n                    result.setDate(date.getDate());\n                    break;\n                case TimeUnit.HOURS:\n                    result.setHours(date.getHours());\n                    break;\n                case TimeUnit.MINUTES:\n                    result.setMinutes(date.getMinutes());\n                    break;\n                case TimeUnit.SECONDS:\n                    result.setSeconds(date.getSeconds());\n                    break;\n                case TimeUnit.MILLISECONDS:\n                    result.setMilliseconds(date.getMilliseconds());\n                    break;\n            }\n        }\n    });\n    return result;\n}\nexports.convert = convert;\nexports.MULTI_TIMEUNITS = [\n    TimeUnit.YEARQUARTER,\n    TimeUnit.YEARQUARTERMONTH,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARMONTHDATEHOURS,\n    TimeUnit.YEARMONTHDATEHOURSMINUTES,\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n    TimeUnit.QUARTERMONTH,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n];\nvar MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {\n    d[timeUnit] = true;\n    return d;\n}, {});\nfunction isMultiTimeUnit(timeUnit) {\n    return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isMultiTimeUnit = isMultiTimeUnit;\nexports.TIMEUNITS = exports.SINGLE_TIMEUNITS.concat(exports.MULTI_TIMEUNITS);\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\n    var fullTimeUnitStr = fullTimeUnit.toString();\n    var timeUnitStr = timeUnit.toString();\n    var index = fullTimeUnitStr.indexOf(timeUnitStr);\n    return index > -1 &&\n        (timeUnit !== TimeUnit.SECONDS ||\n            index === 0 ||\n            fullTimeUnitStr.charAt(index - 1) !== 'i' // exclude milliseconds\n        );\n}\nexports.containsTimeUnit = containsTimeUnit;\nfunction defaultScaleType(timeUnit) {\n    switch (timeUnit) {\n        case TimeUnit.HOURS:\n        case TimeUnit.DAY:\n        case TimeUnit.MONTH:\n        case TimeUnit.QUARTER:\n            return scale_1.ScaleType.ORDINAL;\n    }\n    // date, year, minute, second, yearmonth, monthday, ...\n    return scale_1.ScaleType.TIME;\n}\nexports.defaultScaleType = defaultScaleType;\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nfunction fieldExpr(fullTimeUnit, field) {\n    var fieldRef = 'datum[\"' + field + '\"]';\n    function func(timeUnit) {\n        if (timeUnit === TimeUnit.QUARTER) {\n            // Divide by 3 to get the corresponding quarter number, multiply by 3\n            // to scale to the first month of the corresponding quarter(0,3,6,9).\n            return 'floor(month(' + fieldRef + ')' + '/3)';\n        }\n        else {\n            return timeUnit + '(' + fieldRef + ')';\n        }\n    }\n    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {\n        if (containsTimeUnit(fullTimeUnit, tu)) {\n            _d[tu] = func(tu);\n        }\n        return _d;\n    }, {});\n    if (d.day && util_1.keys(d).length > 1) {\n        console.warn('Time unit \"' + fullTimeUnit + '\" is not supported. We are replacing it with ', (fullTimeUnit + '').replace('day', 'date') + '.');\n        delete d.day;\n        d.date = func(TimeUnit.DATE);\n    }\n    return datetime_1.dateTimeExpr(d);\n}\nexports.fieldExpr = fieldExpr;\n/** Generate the complete raw domain. */\nfunction rawDomain(timeUnit, channel) {\n    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE, channel_1.COLOR], channel)) {\n        return null;\n    }\n    switch (timeUnit) {\n        case TimeUnit.SECONDS:\n            return util_1.range(0, 60);\n        case TimeUnit.MINUTES:\n            return util_1.range(0, 60);\n        case TimeUnit.HOURS:\n            return util_1.range(0, 24);\n        case TimeUnit.DAY:\n            return util_1.range(0, 7);\n        case TimeUnit.DATE:\n            return util_1.range(1, 32);\n        case TimeUnit.MONTH:\n            return util_1.range(0, 12);\n        case TimeUnit.QUARTER:\n            return [0, 3, 6, 9];\n    }\n    return null;\n}\nexports.rawDomain = rawDomain;\n/** returns the smallest nice unit for scale.nice */\nfunction smallestUnit(timeUnit) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        return 'second';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        return 'minute';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        return 'hour';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n        containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        return 'day';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        return 'month';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        return 'year';\n    }\n    return undefined;\n}\nexports.smallestUnit = smallestUnit;\n/** returns the template name used for axis labels for a time unit */\nfunction template(timeUnit, field, shortTimeLabels) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    var dateComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        // special template for quarter\n        dateComponents.push('\\'}}Q{{' + field + ' | quarter}}{{' + field + ' | time:\\'');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        dateComponents.push(shortTimeLabels ? '%b' : '%B');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        dateComponents.push('%d');\n    }\n    var timeComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        timeComponents.push('%H');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        timeComponents.push('%M');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        timeComponents.push('%S');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        timeComponents.push('%L');\n    }\n    var out = [];\n    if (dateComponents.length > 0) {\n        out.push(dateComponents.join('-'));\n    }\n    if (timeComponents.length > 0) {\n        out.push(timeComponents.join(':'));\n    }\n    if (out.length > 0) {\n        // clean up empty formatting expressions that may have been generated by the quarter time unit\n        var template_1 = '{{' + field + ' | time:\\'' + out.join(' ') + '\\'}}';\n        // FIXME: Remove these RegExp Hacks!!!\n        var escapedField = field.replace(/(\\[|\\])/g, '\\\\$1'); // excape field for use in Regex\n        return template_1.replace(new RegExp('{{' + escapedField + ' \\\\| time:\\'\\'}}', 'g'), ''); // remove empty templates with Regex\n    }\n    else {\n        return undefined;\n    }\n}\nexports.template = template;\n//# sourceMappingURL=timeunit.js.map",
    "/** Constants and utilities for data type */\n\"use strict\";\n(function (Type) {\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\n})(exports.Type || (exports.Type = {}));\nvar Type = exports.Type;\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\n/**\n * Mapping from full type names to short type names.\n * @type {Object}\n */\nexports.SHORT_TYPE = {\n    quantitative: 'Q',\n    temporal: 'T',\n    nominal: 'N',\n    ordinal: 'O'\n};\n/**\n * Mapping from short type names to full type names.\n * @type {Object}\n */\nexports.TYPE_FROM_SHORT_TYPE = {\n    Q: exports.QUANTITATIVE,\n    T: exports.TEMPORAL,\n    O: exports.ORDINAL,\n    N: exports.NOMINAL\n};\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nfunction getFullName(type) {\n    var typeString = type; // force type as string so we can translate short types\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\n        typeString.toLowerCase();\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=type.js.map",
    "/// <reference path=\"../typings/datalib.d.ts\"/>\n/// <reference path=\"../typings/json-stable-stringify.d.ts\"/>\n\"use strict\";\nvar stringify = require('json-stable-stringify');\nvar util_1 = require('datalib/src/util');\nexports.keys = util_1.keys;\nexports.extend = util_1.extend;\nexports.duplicate = util_1.duplicate;\nexports.isArray = util_1.isArray;\nexports.vals = util_1.vals;\nexports.truncate = util_1.truncate;\nexports.toMap = util_1.toMap;\nexports.isObject = util_1.isObject;\nexports.isString = util_1.isString;\nexports.isNumber = util_1.isNumber;\nexports.isBoolean = util_1.isBoolean;\nvar util_2 = require('datalib/src/util');\nvar util_3 = require('datalib/src/util');\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n * pick(object, ['a', 'c']);\n * // → { 'a': 1, 'c': 3 }\n *\n */\nfunction pick(obj, props) {\n    var copy = {};\n    props.forEach(function (prop) {\n        if (obj.hasOwnProperty(prop)) {\n            copy[prop] = obj[prop];\n        }\n    });\n    return copy;\n}\nexports.pick = pick;\n// Copied from datalib\nfunction range(start, stop, step) {\n    if (arguments.length < 3) {\n        step = 1;\n        if (arguments.length < 2) {\n            stop = start;\n            start = 0;\n        }\n    }\n    if ((stop - start) / step === Infinity) {\n        throw new Error('Infinite range');\n    }\n    var range = [], i = -1, j;\n    if (step < 0) {\n        /* tslint:disable */\n        while ((j = start + step * ++i) > stop) {\n            range.push(j);\n        }\n    }\n    else {\n        while ((j = start + step * ++i) < stop) {\n            range.push(j);\n        }\n    }\n    return range;\n}\nexports.range = range;\n;\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nfunction omit(obj, props) {\n    var copy = util_2.duplicate(obj);\n    props.forEach(function (prop) {\n        delete copy[prop];\n    });\n    return copy;\n}\nexports.omit = omit;\nfunction hash(a) {\n    if (util_3.isString(a) || util_3.isNumber(a) || util_3.isBoolean(a)) {\n        return String(a);\n    }\n    return stringify(a);\n}\nexports.hash = hash;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\nfunction union(array, other) {\n    return array.concat(without(other, array));\n}\nexports.union = union;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                f.call(thisArg, obj[k], k, obj);\n            }\n        }\n    }\n}\nexports.forEach = forEach;\nfunction reduce(obj, f, init, thisArg) {\n    if (obj.reduce) {\n        return obj.reduce.call(thisArg, f, init);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                init = f.call(thisArg, init, obj[k], k, obj);\n            }\n        }\n        return init;\n    }\n}\nexports.reduce = reduce;\nfunction map(obj, f, thisArg) {\n    if (obj.map) {\n        return obj.map.call(thisArg, f);\n    }\n    else {\n        var output = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                output.push(f.call(thisArg, obj[k], k, obj));\n            }\n        }\n        return output;\n    }\n}\nexports.map = map;\nfunction some(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\nfunction every(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.flatten = flatten;\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < src.length; i++) {\n        dest = deepMerge_(dest, src[i]);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n;\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\nfunction unique(values, f) {\n    var results = [];\n    var u = {}, v, i, n;\n    for (i = 0, n = values.length; i < n; ++i) {\n        v = f ? f(values[i]) : values[i];\n        if (v in u) {\n            continue;\n        }\n        u[v] = 1;\n        results.push(values[i]);\n    }\n    return results;\n}\nexports.unique = unique;\n;\nfunction warning(message) {\n    console.warn('[VL Warning]', message);\n}\nexports.warning = warning;\nfunction error(message) {\n    console.error('[VL Error]', message);\n}\nexports.error = error;\n/**\n * Returns true if the two dicitonaries disagree. Applies only to defioned values.\n */\nfunction differ(dict, other) {\n    for (var key in dict) {\n        if (dict.hasOwnProperty(key)) {\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.differ = differ;\n//# sourceMappingURL=util.js.map"
  ]
}